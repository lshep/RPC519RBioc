[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RPC 519 R and Bioconductor",
    "section": "",
    "text": "Preface\nThis is a selection of material from The RBioc Book created by Sean Davis. The original full content may be viewed here. The contents of this book may have minor modifications or additions.\nThe material is modified and redistributed in accordance with the original Licensing.\nSelect modifications were inspired by RPC 520 content originally distributed by Martin Morgan.\nTo Learn more about creating Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Home",
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  About R",
    "section": "",
    "text": "1.1 What is R?\nIn this chapter, we will discuss the basics of R and RStudio, two essential tools in genomics data analysis. We will cover the advantages of using R and RStudio, how to set up RStudio, and the different panels of the RStudio interface.\nR is a programming language and software environment designed for statistical computing and graphics. It is widely used by statisticians, data scientists, and researchers for data analysis and visualization. R is an open-source language, which means it is free to use, modify, and distribute. Over the years, R has become particularly popular in the fields of genomics and bioinformatics, owing to its extensive libraries and powerful data manipulation capabilities.\nThe R language is a dialect of the S language, which was developed in the 1970s at Bell Laboratories. The first version of R was written by Robert Gentleman and Ross Ihaka and released in 1995 (see this slide deck for Ross Ihaka’s take on R’s history). Since then, R has been continuously developed by the R Core Team, a group of statisticians and computer scientists. The R Core Team releases a new version of R every year.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About R</span>"
    ]
  },
  {
    "objectID": "intro.html#why-use-r",
    "href": "intro.html#why-use-r",
    "title": "1  About R",
    "section": "1.2 Why use R?",
    "text": "1.2 Why use R?\nThere are several reasons why R is a popular choice for data analysis, particularly in genomics and bioinformatics. These include:\n\nOpen-source: R is free to use and has a large community of developers who contribute to its growth and development. What is “open-source”?\nExtensive libraries: There are thousands of R packages available for a wide range of tasks, including specialized packages for genomics and bioinformatics. These libraries have been extensively tested and ara available for free.\nData manipulation: R has powerful data manipulation capabilities, making it easy (or at least possible) to clean, process, and analyze large datasets.\nGraphics and visualization: R has excellent tools for creating high-quality graphics and visualizations that can be customized to meet the specific needs of your analysis. In most cases, graphics produced by R are publication-quality.\nReproducible research: R enables you to create reproducible research by recording your analysis in a script, which can be easily shared and executed by others. In addition, R does not have a meaningful graphical user interface (GUI), which renders analysis in R much more reproducible than tools that rely on GUI interactions.\nCross-platform: R runs on Windows, Mac, and Linux (as well as more obscure systems).\nInteroperability with other languages: R can interfact with FORTRAN, C, and many other languages.\nScalability: R is useful for small and large projects.\n\nI can develop code for analysis on my Mac laptop. I can then install the same code on our 20k core cluster and run it in parallel on 100 samples, monitor the process, and then update a database (for example) with R when complete. In other words, R is a powerful tool that can be used for a wide range of tasks, from small-scale data analysis to large-scale genomics and omics data science projects.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About R</span>"
    ]
  },
  {
    "objectID": "intro.html#why-not-use-r",
    "href": "intro.html#why-not-use-r",
    "title": "1  About R",
    "section": "1.3 Why not use R?",
    "text": "1.3 Why not use R?\n\nR cannot do everything.\nR is not always the “best” tool for the job.\nR will not hold your hand. Often, it will slap your hand instead.\nThe documentation can be opaque (but there is documentation).\nR can drive you crazy (on a good day) or age you prematurely (on a bad one).\nFinding the right package to do the job you want to do can be challenging; worse, some contributed packages are unreliable.]{}\nR does not have a meaningfully useful graphical user interface (GUI).\nAdditional languages are becoming increasingly popular for bioinformatics and biological data science, such as Python, Julia, and Rust.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About R</span>"
    ]
  },
  {
    "objectID": "intro.html#r-license-and-the-open-source-ideal",
    "href": "intro.html#r-license-and-the-open-source-ideal",
    "title": "1  About R",
    "section": "1.4 R License and the Open Source Ideal",
    "text": "1.4 R License and the Open Source Ideal\nR is free (yes, totally free!) and distributed under GNU license. In particular, this license allows one to:\n\nDownload the source code\nModify the source code to your heart’s content\nDistribute the modified source code and even charge money for it, but you must distribute the modified source code under the original GNU license.\n\nThis license means that R will always be available, will always be open source, and can grow organically without constraint.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About R</span>"
    ]
  },
  {
    "objectID": "intro.html#working-with-r",
    "href": "intro.html#working-with-r",
    "title": "1  About R",
    "section": "1.5 Working with R",
    "text": "1.5 Working with R\nR is a programming language, and as such, it requires you to write code to perform tasks. This can be intimidating for beginners, but it is also what makes R so powerful. In R, you can write scripts to automate tasks, create functions to encapsulate complex operations, and use packages to extend the functionality of R.\nR can be used interactively or as a scripting language. In interactive mode, you can enter commands directly into the R console and see the results immediately. In scripting mode, you can write a series of commands in a script file and then execute the entire script at once. This allows you to save your work, reuse code, and share your analysis with others.\nIn the next section, we will discuss how to set up RStudio, an integrated development environment (IDE) for R that makes it easier to write and execute R code. However, you can use R without RStudio if you prefer to work in the R console or another IDE. RStudio is not required to use R, but it does provide a more user-friendly interface and several useful features that can enhance your R programming experience.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About R</span>"
    ]
  },
  {
    "objectID": "intro_to_rstudio.html",
    "href": "intro_to_rstudio.html",
    "title": "2  RStudio",
    "section": "",
    "text": "2.1 Getting started with RStudio\nRStudio is an integrated development environment (IDE) for R. It provides a graphical user interface (GUI) for R, making it easier to write and execute R code. RStudio also provides several other useful features, including a built-in console, syntax-highlighting editor, and tools for plotting, history, debugging, workspace management, and workspace viewing. RStudio is available in both free and commercial editions; the commercial edition provides some additional features, including support for multiple sessions and enhanced debugging.\nTo get started with RStudio, you first need to install both R and RStudio on your computer. Follow these steps:",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>RStudio</span>"
    ]
  },
  {
    "objectID": "intro_to_rstudio.html#getting-started-with-rstudio",
    "href": "intro_to_rstudio.html#getting-started-with-rstudio",
    "title": "2  RStudio",
    "section": "",
    "text": "Download and install R from the official R website.\nDownload and install RStudio from the official RStudio website.\nLaunch RStudio. You should see the RStudio interface with four panels.\n\n\n\n\n\n\n\nR versions\n\n\n\nRStudio works with all versions of R, but it is recommended to use the latest version of R to take advantage of the latest features and improvements. You can check your R version by running version (no parentheses)in the R console.\nYou can check the latest version of R on the R-project website.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>RStudio</span>"
    ]
  },
  {
    "objectID": "intro_to_rstudio.html#the-rstudio-interface",
    "href": "intro_to_rstudio.html#the-rstudio-interface",
    "title": "2  RStudio",
    "section": "2.2 The RStudio Interface",
    "text": "2.2 The RStudio Interface\nRStudio’s interface consists of four panels (see Figure 2.1):\n\n\nConsole\n\nThis panel displays the R console, where you can enter and execute R commands directly. The console also shows the output of your code, error messages, and other information.\n\n\n\nSource\n\nThis panel is where you write and edit your R scripts. You can create new scripts, open existing ones, and run your code from this panel.\n\n\n\nEnvironment\n\nThis panel displays your current workspace, including all variables, data objects, and functions that you have created or loaded in your R session.\n\n\n\nPlots, Packages, Help, and Viewer\n\nThese panels display plots, installed packages, help files, and web content, respectively.\n\n\n\n\n\n\n\n\n\nFigure 2.1: The RStudio interface. In this layout, the source pane is in the upper left, the console is in the lower left, the environment panel is in the top right and the viewer/help/files panel is in the bottom right.\n\n\n\n\n\n\n\n\n\nDo I need to use RStudio?\n\n\n\nNo. You can use R without RStudio. However, RStudio makes it easier to write and execute R code, and it provides several useful features that are not available in the basic R console. Note that the only part of RStudio that is actually interacting with R directly is the console. The other panels are simply providing a GUI that enhances the user experience.\n\n\n\n\n\n\n\n\nCustomizing the RStudio Interface\n\n\n\nYou can customize the layout of RStudio to suit your preferences. To do so, go to Tools &gt; Global Options &gt; Appearance. Here, you can change the theme, font size, and panel layout. You can also resize the panels as needed to gain screen real estate (see Figure 2.2).\n\n\n\n\n\n\n\n\nFigure 2.2: Dealing with limited screen real estate can be a challenge, particularly when you want to open another window to, for example, view a web page. You can resize the panes by sliding the center divider (red arrows) or by clicking on the minimize/maximize buttons (see blue arrow).\n\n\n\nIn summary, R and RStudio are powerful tools for genomics data analysis. By understanding the advantages of using R and RStudio and familiarizing yourself with the RStudio interface, you can efficiently analyze and visualize your data. In the following chapters, we will delve deeper into the functionality of R, Bioconductor, and various statistical methods to help you gain a comprehensive understanding of genomics data analysis.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>RStudio</span>"
    ]
  },
  {
    "objectID": "intro_to_rstudio.html#alternatives-to-rstudio",
    "href": "intro_to_rstudio.html#alternatives-to-rstudio",
    "title": "2  RStudio",
    "section": "2.3 Alternatives to RStudio",
    "text": "2.3 Alternatives to RStudio\nWhile RStudio is a popular choice for R development, there are several alternatives you can consider:\n\nJupyter Notebooks: Jupyter Notebooks provide an interactive environment for writing and executing R code, along with rich text support for documentation. You can use the IRKernel to run R code in Jupyter.\n\n\n\n\nJupyter Notebook interface. This is an interactive environment for writing and executing R code, along with rich text support for documentation.\n\n\n\nVisual Studio Code: With the R extension for Visual Studio Code, you can write and execute R code in a lightweight editor. This setup provides features like syntax highlighting, code completion, and integrated terminal support.\n\n\n\n\nVisual Studio Code (VSCode) with the R extension. This is a lightweight alternative to RStudio that provides syntax highlighting, code completion, and integrated terminal support.\n\n\n\nPositron Workbench: This is a commercial IDE that supports R and Python. It provides a similar interface to RStudio but with additional features for data science workflows, including support for multiple languages and cloud integration.\n\n\n\n\nPositron Workbench interface. This IDE supports R and Python, providing a similar interface to RStudio with additional features for data science workflows.\n\n\n\nCommand Line R: For those who prefer a minimalistic approach, you can use R directly from the command line. This method lacks the GUI features of RStudio but can be efficient for quick tasks, scripting, automation, or when working on remote servers.\n\nEach of these alternatives has its own strengths and weaknesses, so you may want to try a few to see which one best fits your workflow. All are available for free, and you can install them alongside RStudio if you wish to use multiple environments. Each can be installed in Windows, Mac, and Linux.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>RStudio</span>"
    ]
  },
  {
    "objectID": "r_intro_mechanics.html",
    "href": "r_intro_mechanics.html",
    "title": "3  R mechanics",
    "section": "",
    "text": "3.1 Starting R\nWe’ve installed R and RStudio. Now, let’s start R and get going. How to start R depends a bit on the operating system (Mac, Windows, Linux) and interface. In this course, we will largely be using an Integrated Development Environment (IDE) called RStudio, but there is nothing to prohibit using R at the command line or in some other interface (and there are a few).",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R mechanics</span>"
    ]
  },
  {
    "objectID": "r_intro_mechanics.html#rstudio-a-quick-tour",
    "href": "r_intro_mechanics.html#rstudio-a-quick-tour",
    "title": "3  R mechanics",
    "section": "3.2 RStudio: A Quick Tour",
    "text": "3.2 RStudio: A Quick Tour\nThe RStudio interface has multiple panes. All of these panes are simply for convenience except the “Console” panel, typically in the lower left corner (by default). The console pane contains the running R interface. If you choose to run R outside RStudio, the interaction will be identical to working in the console pane. This is useful to keep in mind as some environments, such as a computer cluster, encourage using R without RStudio.\n\nPanes\nOptions\nHelp\nEnvironment, History, and Files",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R mechanics</span>"
    ]
  },
  {
    "objectID": "r_intro_mechanics.html#interacting-with-r",
    "href": "r_intro_mechanics.html#interacting-with-r",
    "title": "3  R mechanics",
    "section": "3.3 Interacting with R",
    "text": "3.3 Interacting with R\nThe only meaningful way of interacting with R is by typing into the R console. At the most basic level, anything that we type at the command line will fall into one of two categories:\n\nAssignments\n\nx = 1\ny &lt;- 2\n\nExpressions\n\n1 + pi + sin(42)\n\n[1] 3.225071\n\n\n\nThe assignment type is obvious because either the The &lt;- or = are used. Note that when we type expressions, R will return a result. In this case, the result of R evaluating 1 + pi + sin(42) is 3.2250711.\nThe standard R prompt is a “&gt;” sign. When present, R is waiting for the next expression or assignment. If a line is not a complete R command, R will continue the next line with a “+”. For example, typing the following with a “Return” after the second “+” will result in R giving back a “+” on the next line, a prompt to keep typing.\n\n1 + pi +\nsin(3.7)\n\n[1] 3.611757\n\n\nR can be used as a glorified calculator by using R expressions. Mathematical operations include:\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: /\nExponentiation: ^\nModulo: %%\n\nThe ^ operator raises the number to its left to the power of the number to its right: for example 3^2 is 9. The modulo returns the remainder of the division of the number to the left by the number on its right, for example 5 modulo 3 or 5 %% 3 is 2.\n\n3.3.1 Expressions\n\n5 + 2\n28 %% 3\n3^2\n5 + 4 * 4 + 4 ^ 4 / 10\n\nNote that R follows order-of-operations and groupings based on parentheses.\n\n5 + 4 / 9\n(5 + 4) / 9\n\n\n\n3.3.2 Assignment\nWhile using R as a calculator is interesting, to do useful and interesting things, we need to assign values to objects. To create objects, we need to give it a name followed by the assignment operator &lt;- (or, entirely equivalently, =) and the value we want to give it:\n\nweight_kg &lt;- 55 \n\n&lt;- is the assignment operator. Assigns values on the right to objects on the left, it is like an arrow that points from the value to the object. Using an = is equivalent (in nearly all cases). Learn to use &lt;- as it is good programming practice.\n\n\n\n\n\n\nWhat about &lt;- and = for assignment?\n\n\n\nThe &lt;- and = both work fine for assignment. You’ll see both used and it is up to you to choose a standard for yourself. However, some programming communities, such as Bioconductor, will strongly suggest using the &lt;- as it is clearer that it represents an assignment operation.\n\n\nObjects can be given any name such as x, current_temperature, or subject_id (see below). You want your object names to be explicit and not too long. They cannot start with a number (2x is not valid but x2 is). R is case sensitive (e.g., weight_kg is different from Weight_kg). There are some names that cannot be used because they represent the names of fundamental functions in R (e.g., if, else, for, see here for a complete list). In general, even if it’s allowed, it’s best to not use other function names, which we’ll get into shortly (e.g., c, T, mean, data, df, weights). When in doubt, check the help to see if the name is already in use. It’s also best to avoid dots (.) within a variable name as in my.dataset. It is also recommended to use nouns for variable names, and verbs for function names.\nWhen assigning a value to an object, R does not print anything. You can force to print the value by typing the name:\n\nweight_kg\n\n[1] 55\n\n\nNow that R has weight_kg in memory, which R refers to as the “global environment”, we can do arithmetic with it. For instance, we may want to convert this weight in pounds (weight in pounds is 2.2 times the weight in kg).\n\n2.2 * weight_kg\n\n[1] 121\n\n\nWe can also change a variable’s value by assigning it a new one:\n\nweight_kg &lt;- 57.5\n2.2 * weight_kg\n\n[1] 126.5\n\n\nThis means that assigning a value to one variable does not change the values of other variables. For example, let’s store the animal’s weight in pounds in a variable.\n\nweight_lb &lt;- 2.2 * weight_kg\n\nand then change weight_kg to 100.\n\nweight_kg &lt;- 100\n\nWhat do you think is the current content of the object weight_lb, 126.5 or 220?\nYou can see what objects (variables) are stored by viewing the Environment tab in Rstudio. You can also use the ls() function. You can remove objects (variables) with the rm() function. You can do this one at a time or remove several objects at once. You can also use the little broom button in your environment pane to remove everything from your environment.\n\nls()\nrm(weight_lb, weight_kg)\nls()\n\nWhat happens when you type the following, now?\n\nweight_lb # oops! you should get an error because weight_lb no longer exists!",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R mechanics</span>"
    ]
  },
  {
    "objectID": "r_intro_mechanics.html#rules-for-names-in-r",
    "href": "r_intro_mechanics.html#rules-for-names-in-r",
    "title": "3  R mechanics",
    "section": "3.4 Rules for Names in R",
    "text": "3.4 Rules for Names in R\nR allows users to assign names to objects such as variables, functions, and even dimensions of data. However, these names must follow a few rules.\n\nNames may contain any combination of letters, numbers, underscore, and “.”\nNames may not start with numbers, underscore.\nR names are case-sensitive.\n\nExamples of valid R names include:\npi\nx\ncamelCaps\nmy_stuff\nMY_Stuff\nthis.is.the.name.of.the.man\nABC123\nabc1234asdf\n.hi",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R mechanics</span>"
    ]
  },
  {
    "objectID": "r_intro_mechanics.html#about-r-functions",
    "href": "r_intro_mechanics.html#about-r-functions",
    "title": "3  R mechanics",
    "section": "3.5 About R functions",
    "text": "3.5 About R functions\nWhen you see a name followed by parentheses (), you are likely looking a name that represents an R function (or method, but we’ll sidestep that distinction for now). Examples of R functions include print(), help(), and ls(). We haven’t seen examples yet, but when a name is followed by [], that name represents a variable of some kind and the [] are used for “subsetting” the variable. So:\n\nName followed by () is a function.\nName with [] means a variable that is being subset.\n\nIn many cases, when you see a new function used, you may not know what it does. The R help() function takes the name of another function and gives back the R help document for that function if there is one. The next section reviews that technique.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R mechanics</span>"
    ]
  },
  {
    "objectID": "r_intro_mechanics.html#resources-for-getting-help",
    "href": "r_intro_mechanics.html#resources-for-getting-help",
    "title": "3  R mechanics",
    "section": "3.6 Resources for Getting Help",
    "text": "3.6 Resources for Getting Help\nThere is extensive built-in help and documentation within R. A separate page contains a collection of additional resources.\nIf the name of the function or object on which help is sought is known, the following approaches with the name of the function or object will be helpful. For a concrete example, examine the help for the print method.\n\nhelp(print)\nhelp('print')\n?print\n\nThere are also tons of online resources that Google will include in searches if online searching feels more appropriate.\nI strongly recommend using help(\"newfunction\") for all functions that are new or unfamiliar to you.\nThere are also many open and free resources and reference guides for R.\n\nQuick-R: a quick online reference for data input, basic statistics and plots\nR reference card PDF by Tom Short\nRstudio cheatsheets",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R mechanics</span>"
    ]
  },
  {
    "objectID": "r_intro_mechanics.html#reflection",
    "href": "r_intro_mechanics.html#reflection",
    "title": "3  R mechanics",
    "section": "3.7 Reflection",
    "text": "3.7 Reflection\n\nCan you recognize the difference between assignment and expressions when interacting with R?\nCan you demonstrate an assignment to a variable?\nDo you know the rules for “names” in R?\nAre you able to get help using the R help() function?\nDo you know that functions are recognizable as names followed by ()?",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R mechanics</span>"
    ]
  },
  {
    "objectID": "r_basics.html",
    "href": "r_basics.html",
    "title": "4  Up and Running with R",
    "section": "",
    "text": "4.1 The R User Interface\nIn this chapter, we’re going to get an introduction to the R language, so we can dive right into programming. We’re going to create a pair of virtual dice that can generate random numbers. No need to worry if you’re new to programming. We’ll return to many of the concepts here in more detail later.\nTo simulate a pair of dice, we need to break down each die into its essential features. A die can only show one of six numbers: 1, 2, 3, 4, 5, and 6. We can capture the die’s essential characteristics by saving these numbers as a group of values in the computer. Let’s save these numbers first and then figure out a way to “roll” our virtual die.\nThe RStudio interface is simple. You type R code into the bottom line of the RStudio console pane and then click Enter to run it. The code you type is called a command, because it will command your computer to do something for you. The line you type it into is called the command line.\nWhen you type a command at the prompt and hit Enter, your computer executes the command and shows you the results. Then RStudio displays a fresh prompt for your next command. For example, if you type 1 + 1 and hit Enter, RStudio will display:\nYou’ll notice that a [1] appears next to your result. R is just letting you know that this line begins with the first value in your result. Some commands return more than one value, and their results may fill up multiple lines. For example, the command 100:130 returns 31 values; it creates a sequence of integers from 100 to 130. Notice that new bracketed numbers appear at the start of the second and third lines of output. These numbers just mean that the second line begins with the 14th value in the result, and the third line begins with the 25th value. You can mostly ignore the numbers that appear in brackets:\nIf you type an incomplete command and press Enter, R will display a + prompt, which means R is waiting for you to type the rest of your command. Either finish the command or hit Escape to start over:\nIf you type a command that R doesn’t recognize, R will return an error message. If you ever see an error message, don’t panic. R is just telling you that your computer couldn’t understand or do what you asked it to do. You can then try a different command at the next prompt:\nOnce you get the hang of the command line, you can easily do anything in R that you would do with a calculator. For example, you could do some basic arithmetic:\n2 * 3   \n\n[1] 6\n\n4 - 1   \n\n[1] 3\n\n# this obeys order-of-operations\n6 / (4 - 1)   \n\n[1] 2",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "r_basics.html#the-r-user-interface",
    "href": "r_basics.html#the-r-user-interface",
    "title": "4  Up and Running with R",
    "section": "",
    "text": "Figure 4.1: Your computer does your bidding when you type R commands at the prompt in the bottom line of the console pane. Don’t forget to hit the Enter key. When you first open RStudio, the console appears in the pane on your left, but you can change this with File &gt; Tools &gt; Global Options in the menu bar.\n\n\n\n\n&gt; 1 + 1\n[1] 2\n&gt;\n\n&gt; 100:130\n [1] 100 101 102 103 104 105 106 107 108 109 110 111 112\n[14] 113 114 115 116 117 118 119 120 121 122 123 124 125\n[25] 126 127 128 129 130\n\n\n\n\n\n\nTip\n\n\n\nThe colon operator (:) returns every integer between two integers. It is an easy way to create a sequence of numbers.\n\n\n\n\n\n\n\n\nWhen do we compile?\n\n\n\nIn some languages, like C, Java, and FORTRAN, you have to compile your human-readable code into machine-readable code (often 1s and 0s) before you can run it. If you’ve programmed in such a language before, you may wonder whether you have to compile your R code before you can use it. The answer is no. R is a dynamic programming language, which means R automatically interprets your code as you run it.\n\n\n\n&gt; 5 -\n+\n+ 1\n[1] 4\n\n&gt; 3 % 5\nError: unexpected input in \"3 % 5\"\n&gt;\n\n\n\n\n\n\nTip\n\n\n\nWhenever you get an error message in R, consider googling the error message. You’ll often find that someone else has had the same problem and has posted a solution online. Simply cutting-and-pasting the error message into a search engine will often work\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nR treats the hashtag character, #, in a special way; R will not run anything that follows a hashtag on a line. This makes hashtags very useful for adding comments and annotations to your code. Humans will be able to read the comments, but your computer will pass over them. The hashtag is known as the commenting symbol in R.\n\n\n\n\n\n\n\n\nCancelling commands\n\n\n\nSome R commands may take a long time to run. You can cancel a command once it has begun by pressing ctrl + c or by clicking the “stop sign” if it is available in Rstudio. Note that it may also take R a long time to cancel the command.\n\n\n\n4.1.1 An exercise\nThat’s the basic interface for executing R code in RStudio. Think you have it? If so, try doing these simple tasks. If you execute everything correctly, you should end up with the same number that you started with:\n\nChoose any number and add 2 to it.\nMultiply the result by 3.\nSubtract 6 from the answer.\nDivide what you get by 3.\n\n\n10 + 2\n\n[1] 12\n\n12 * 3\n\n[1] 36\n\n36 - 6\n\n[1] 30\n\n30 / 3\n\n[1] 10",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "r_basics.html#objects",
    "href": "r_basics.html#objects",
    "title": "4  Up and Running with R",
    "section": "4.2 Objects",
    "text": "4.2 Objects\nNow that you know how to use R, let’s use it to make a virtual die. The : operator from a couple of pages ago gives you a nice way to create a group of numbers from one to six. The : operator returns its results as a vector (we are going to work with vectors in more detail), a one-dimensional set of numbers:\n1:6\n## 1 2 3 4 5 6\nThat’s all there is to how a virtual die looks! But you are not done yet. Running 1:6 generated a vector of numbers for you to see, but it didn’t save that vector anywhere for later use. If we want to use those numbers again, we’ll have to ask your computer to save them somewhere. You can do that by creating an R object.\nR lets you save data by storing it inside an R object. What is an object? Just a name that you can use to call up stored data. For example, you can save data into an object like a or b. Wherever R encounters the object, it will replace it with the data saved inside, like so:\n\na &lt;- 1\na\n\n[1] 1\n\n\n\na + 2\n\n[1] 3\n\n\n\n\n\n\n\n\nWhat just happened?\n\n\n\n\nTo create an R object, choose a name and then use the less-than symbol, &lt;, followed by a minus sign, -, to save data into it. This combination looks like an arrow, &lt;-. R will make an object, give it your name, and store in it whatever follows the arrow. So a &lt;- 1 stores 1 in an object named a.\nWhen you ask R what’s in a, R tells you on the next line.\nYou can use your object in new R commands, too. Since a previously stored the value of 1, you’re now adding 1 to 2.\n\n\n\n\n\n\n\n\n\nAssignment vs expressions\n\n\n\nEverything that you type into the R console can be assigned to one of two categories:\n\nAssignments\nExpressions\n\nAn expression is a command that tells R to do something. For example, 1 + 2 is an expression that tells R to add 1 and 2. When you type an expression into the R console, R will evaluate the expression and return the result. For example, if you type 1 + 2 into the R console, R will return 3. Expressions can have “side effects” but they don’t explicitly result in anything being added to R memory.\n\n5 + 2\n\n[1] 7\n\n28 %% 3\n\n[1] 1\n\n3^2\n\n[1] 9\n\n5 + 4 * 4 + 4 ^ 4 / 10\n\n[1] 46.6\n\n\nWhile using R as a calculator is interesting, to do useful and interesting things, we need to assign values to objects. To create objects, we need to give it a name followed by the assignment operator &lt;- (or, entirely equivalently, =) and the value we want to give it:\n\nweight_kg &lt;- 55\n\n\n\nSo, for another example, the following code would create an object named die that contains the numbers one through six. To see what is stored in an object, just type the object’s name by itself:\n\ndie &lt;- 1:6\ndie\n\n[1] 1 2 3 4 5 6\n\n\nWhen you create an object, the object will appear in the environment pane of RStudio, as shown in Figure 4.2. This pane will show you all of the objects you’ve created since opening RStudio.\n\n\n\n\n\n\nFigure 4.2: Assignment creates an object in the environment pane.\n\n\n\nYou can name an object in R almost anything you want, but there are a few rules. First, a name cannot start with a number. Second, a name cannot use some special symbols, like ^, !, $, @, +, -, /, or *:\n\n\n\nGood names\nNames that cause errors\n\n\n\n\na\n1trial\n\n\nb\n$\n\n\nFOO\n^mean\n\n\nmy_var\n2nd\n\n\n.day\n!bad\n\n\n\n\n\n\n\n\n\nCapitalization matters\n\n\n\nR is case-sensitive, so name and Name will refer to different objects:\n&gt; Name = 0\n&gt; Name + 1\n[1] 1\n&gt; name + 1\nError: object 'name' not found\nThe error above is a common one!\n\n\nFinally, R will overwrite any previous information stored in an object without asking you for permission. So, it is a good idea to not use names that are already taken:\n\nmy_number &lt;- 1\nmy_number \n\n[1] 1\n\n\n\nmy_number &lt;- 999\nmy_number\n\n[1] 999\n\n\nYou can see which object names you have already used with the function ls:\nls()\nYour environment will contain different names than mine, because you have probably created different objects.\nYou can also see which names you have used by examining RStudio’s environment pane.\nWe now have a virtual die that is stored in the computer’s memory and which has a name that we can use to refer to it. You can access it whenever you like by typing the word die.\nSo what can you do with this die? Quite a lot. R will replace an object with its contents whenever the object’s name appears in a command. So, for example, you can do all sorts of math with the die. Math isn’t so helpful for rolling dice, but manipulating sets of numbers will be your stock and trade as a data scientist. So let’s take a look at how to do that:\n\ndie - 1\n\n[1] 0 1 2 3 4 5\n\ndie / 2\n\n[1] 0.5 1.0 1.5 2.0 2.5 3.0\n\ndie * die\n\n[1]  1  4  9 16 25 36\n\n\nR uses element-wise execution when working with a vector like die. When you manipulate a set of numbers, R will apply the same operation to each element in the set. So for example, when you run die - 1, R subtracts one from each element of die.\nWhen you use two or more vectors in an operation, R will line up the vectors and perform a sequence of individual operations. For example, when you run die * die, R lines up the two die vectors and then multiplies the first element of vector 1 by the first element of vector 2. R then multiplies the second element of vector 1 by the second element of vector 2, and so on, until every element has been multiplied. The result will be a new vector the same length as the first two {Figure 4.3}.\n\n\n\n\n\n\nFigure 4.3: “When R performs element-wise execution, it matches up vectors and then manipulates each pair of elements independently.”\n\n\n\nIf you give R two vectors of unequal lengths, R will repeat the shorter vector until it is as long as the longer vector, and then do the math, as shown in Figure 4.4. This isn’t a permanent change–the shorter vector will be its original size after R does the math. If the length of the short vector does not divide evenly into the length of the long vector, R will return a warning message. This behavior is known as vector recycling, and it helps R do element-wise operations:\n\n1:2\n\n[1] 1 2\n\n1:4\n\n[1] 1 2 3 4\n\ndie\n\n[1] 1 2 3 4 5 6\n\ndie + 1:2\n\n[1] 2 4 4 6 6 8\n\ndie + 1:4\n\nWarning in die + 1:4: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 8 6 8\n\n\n\n\n\n\n\n\nFigure 4.4: “R will repeat a short vector to do element-wise operations with two vectors of uneven lengths.”\n\n\n\nElement-wise operations are a very useful feature in R because they manipulate groups of values in an orderly way. When you start working with data sets, element-wise operations will ensure that values from one observation or case are only paired with values from the same observation or case. Element-wise operations also make it easier to write your own programs and functions in R.\n\n\n\n\n\n\nElement-wise operations are not matrix operations\n\n\n\nIt is important to know that operations with vectors are not the same that you might expect if you are expecting R to perform “matrix” operations. R can do inner multiplication with the %*% operator and outer multiplication with the %o% operator:\n# Inner product (1*1 + 2*2 + 3*3 + 4*4 + 5*5 + 6*6)\ndie %*% die\n# Outer product\ndie %o% die\n\n\nNow that you can do math with your die object, let’s look at how you could “roll” it. Rolling your die will require something more sophisticated than basic arithmetic; you’ll need to randomly select one of the die’s values. And for that, you will need a function.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "r_basics.html#functions",
    "href": "r_basics.html#functions",
    "title": "4  Up and Running with R",
    "section": "4.3 Functions",
    "text": "4.3 Functions\nR has many functions and puts them all at our disposal. We can use functions to do simple and sophisticated tasks. For example, we can round a number with the round function, or calculate its factorial with the factorial function. Using a function is pretty simple. Just write the name of the function and then the data you want the function to operate on in parentheses:\n\nround(3.1415)\n\n[1] 3\n\nfactorial(3)\n\n[1] 6\n\n\nThe data that you pass into the function is called the function’s argument. The argument can be raw data, an R object, or even the results of another R function. In this last case, R will work from the innermost function to the outermost Figure 4.5.\n\nmean(1:6)\n\n[1] 3.5\n\nmean(die)\n\n[1] 3.5\n\nround(mean(die))\n\n[1] 4\n\n\n\n\n\n\n\n\nFigure 4.5: “When you link functions together, R will resolve them from the innermost operation to the outermost. Here R first looks up die, then calculates the mean of one through six, then rounds the mean.”\n\n\n\nReturning to our die, we can use the sample function to randomly select one of the die’s values; in other words, the sample function can simulate rolling the die.\nThe sample function takes two arguments: a vector named x and a number named size. sample will return size elements from the vector:\n\nsample(x = 1:4, size = 2)\n\n[1] 1 2\n\n\nTo roll your die and get a number back, set x to die and sample one element from it. You’ll get a new (maybe different) number each time you roll it:\n\nsample(x = die, size = 1)\n\n[1] 4\n\nsample(x = die, size = 1)\n\n[1] 2\n\nsample(x = die, size = 1)\n\n[1] 1\n\n\nMany R functions take multiple arguments that help them do their job. You can give a function as many arguments as you like as long as you separate each argument with a comma.\nYou may have noticed that I set die and 1 equal to the names of the arguments in sample, x and size. Every argument in every R function has a name. You can specify which data should be assigned to which argument by setting a name equal to data, as in the preceding code. This becomes important as you begin to pass multiple arguments to the same function; names help you avoid passing the wrong data to the wrong argument. However, using names is optional. You will notice that R users do not often use the name of the first argument in a function. So you might see the previous code written as:\n\nsample(die, size = 1)\n\n[1] 4\n\n\nOften, the name of the first argument is not very descriptive, and it is usually obvious what the first piece of data refers to anyways.\nBut how do you know which argument names to use? If you try to use a name that a function does not expect, you will likely get an error:\nround(3.1415, corners = 2)\n## Error in round(3.1415, corners = 2) : unused argument(s) (corners = 2)\nIf you’re not sure which names to use with a function, you can look up the function’s arguments with args. To do this, place the name of the function in the parentheses behind args. For example, you can see that the round function takes two arguments, one named x and one named digits:\n\nargs(round)\n\nfunction (x, digits = 0, ...) \nNULL\n\n\nDid you notice that args shows that the digits argument of round is already set to 0? Frequently, an R function will take optional arguments like digits. These arguments are considered optional because they come with a default value. You can pass a new value to an optional argument if you want, and R will use the default value if you do not. For example, round will round your number to 0 digits past the decimal point by default. To override the default, supply your own value for digits:\n\nround(3.1415)\n\n[1] 3\n\nround(3.1415, digits = 2)\n\n[1] 3.14\n\n# pi happens to be a built-in value in R\npi\n\n[1] 3.141593\n\nround(pi)\n\n[1] 3\n\n\nYou should write out the names of each argument after the first one or two when you call a function with multiple arguments. Why? First, this will help you and others understand your code. It is usually obvious which argument your first input refers to (and sometimes the second input as well). However, you’d need a large memory to remember the third and fourth arguments of every R function. Second, and more importantly, writing out argument names prevents errors.\nIf you do not write out the names of your arguments, R will match your values to the arguments in your function by order. For example, in the following code, the first value, die, will be matched to the first argument of sample, which is named x. The next value, 1, will be matched to the next argument, size:\n\nsample(die, 1)\n\n[1] 5\n\n\nAs you provide more arguments, it becomes more likely that your order and R’s order may not align. As a result, values may get passed to the wrong argument. Argument names prevent this. R will always match a value to its argument name, no matter where it appears in the order of arguments:\n\nsample(size = 1, x = die)\n\n[1] 3\n\n\n\n4.3.1 Sample with Replacement\nIf you set size = 2, you can almost simulate a pair of dice. Before we run that code, think for a minute why that might be the case. sample will return two numbers, one for each die:\n\nsample(die, size = 2)\n\n[1] 6 3\n\n\nI said this “almost” works because this method does something funny. If you use it many times, you’ll notice that the second die never has the same value as the first die, which means you’ll never roll something like a pair of threes or snake eyes. What is going on?\nBy default, sample builds a sample without replacement. To see what this means, imagine that sample places all of the values of die in a jar or urn. Then imagine that sample reaches into the jar and pulls out values one by one to build its sample. Once a value has been drawn from the jar, sample sets it aside. The value doesn’t go back into the jar, so it cannot be drawn again. So if sample selects a six on its first draw, it will not be able to select a six on the second draw; six is no longer in the jar to be selected. Although sample creates its sample electronically, it follows this seemingly physical behavior.\nOne side effect of this behavior is that each draw depends on the draws that come before it. In the real world, however, when you roll a pair of dice, each die is independent of the other. If the first die comes up six, it does not prevent the second die from coming up six. In fact, it doesn’t influence the second die in any way whatsoever. You can recreate this behavior in sample by adding the argument replace = TRUE:\n\nsample(die, size = 2, replace = TRUE)\n\n[1] 3 6\n\n\nThe argument replace = TRUE causes sample to sample with replacement. Our jar example provides a good way to understand the difference between sampling with replacement and without. When sample uses replacement, it draws a value from the jar and records the value. Then it puts the value back into the jar. In other words, sample replaces each value after each draw. As a result, sample may select the same value on the second draw. Each value has a chance of being selected each time. It is as if every draw were the first draw.\nSampling with replacement is an easy way to create independent random samples. Each value in your sample will be a sample of size one that is independent of the other values. This is the correct way to simulate a pair of dice:\n\nsample(die, size = 2, replace = TRUE)\n\n[1] 5 2\n\n\nCongratulate yourself; you’ve just run your first simulation in R! You now have a method for simulating the result of rolling a pair of dice. If you want to add up the dice, you can feed your result straight into the sum function:\n\ndice &lt;- sample(die, size = 2, replace = TRUE)\ndice\n\n[1] 1 5\n\nsum(dice)\n\n[1] 6\n\n\nWhat would happen if you call dice multiple times? Would R generate a new pair of dice values each time? Let’s give it a try:\n\ndice\n\n[1] 1 5\n\ndice\n\n[1] 1 5\n\ndice\n\n[1] 1 5\n\n\nThe name dice refers to a vector of two numbers. Calling more than once does not change the value. Each time you call dice, R will show you the result of that one time you called sample and saved the output to dice. R won’t rerun sample(die, 2, replace = TRUE) to create a new roll of the dice. Once you save a set of results to an R object, those results do not change.\nHowever, it would be convenient to have an object that can re-roll the dice whenever you call it. You can make such an object by writing your own R function.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "r_basics.html#write-functions",
    "href": "r_basics.html#write-functions",
    "title": "4  Up and Running with R",
    "section": "4.4 Writing Your Own Functions",
    "text": "4.4 Writing Your Own Functions\nTo recap, you already have working R code that simulates rolling a pair of dice:\n\ndie &lt;- 1:6\ndice &lt;- sample(die, size = 2, replace = TRUE)\nsum(dice)\n\n[1] 5\n\n\nYou can retype this code into the console anytime you want to re-roll your dice. However, this is an awkward way to work with the code. It would be easier to use your code if you wrapped it into its own function, which is exactly what we’ll do now. We’re going to write a function named roll that you can use to roll your virtual dice. When you’re finished, the function will work like this: each time you call roll(), R will return the sum of rolling two dice:\nroll()\n## 8 \n\nroll()\n## 3\n\nroll()\n## 7\nFunctions may seem mysterious or fancy, but they are just another type of R object. Instead of containing data, they contain code. This code is stored in a special format that makes it easy to reuse the code in new situations. You can write your own functions by recreating this format.\n\n4.4.1 The Function Constructor\nEvery function in R has three basic parts: a name, a body of code, and a set of arguments. To make your own function, you need to replicate these parts and store them in an R object, which you can do with the function function. To do this, call function() and follow it with a pair of braces, {}:\n\nmy_function &lt;- function() {}\n\nThis function, as written, doesn’t do anything (yet). However, it is a valid function. You can call it by typing its name followed by an open and closed parenthesis:\n\nmy_function()\n\nNULL\n\n\nfunction will build a function out of whatever R code you place between the braces. For example, you can turn your dice code into a function by calling:\n\nroll &lt;- function() {\n  die &lt;- 1:6\n  dice &lt;- sample(die, size = 2, replace = TRUE)\n  sum(dice)\n}\n\n\n\n\n\n\n\nIndentation and readability\n\n\n\nNotice each line of code between the braces is indented. This makes the code easier to read but has no impact on how the code runs. R ignores spaces and line breaks and executes one complete expression at a time. Note that in other languages like python, spacing is extremely important and part of the language.\n\n\nJust hit the Enter key between each line after the first brace, {. R will wait for you to type the last brace, }, before it responds.\nDon’t forget to save the output of function to an R object. This object will become your new function. To use it, write the object’s name followed by an open and closed parenthesis:\n\nroll()\n\n[1] 5\n\n\nYou can think of the parentheses as the “trigger” that causes R to run the function. If you type in a function’s name without the parentheses, R will show you the code that is stored inside the function. If you type in the name with the parentheses, R will run that code:\n\nroll\n\nfunction () \n{\n    die &lt;- 1:6\n    dice &lt;- sample(die, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nroll()\n\n[1] 11\n\n\nThe code that you place inside your function is known as the body of the function. When you run a function in R, R will execute all of the code in the body and then return the result of the last line of code. If the last line of code doesn’t return a value, neither will your function, so you want to ensure that your final line of code returns a value. One way to check this is to think about what would happen if you ran the body of code line by line in the command line. Would R display a result after the last line, or would it not?\nHere’s some code that would display a result:\ndice\n1 + 1\nsqrt(2)\nAnd here’s some code that would not:\ndice &lt;- sample(die, size = 2, replace = TRUE)\ntwo &lt;- 1 + 1\na &lt;- sqrt(2)\nAgain, this is just showing the distinction between expressions and assignments.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "r_basics.html#arguments",
    "href": "r_basics.html#arguments",
    "title": "4  Up and Running with R",
    "section": "4.5 Arguments",
    "text": "4.5 Arguments\nWhat if we removed one line of code from our function and changed the name die to bones (just a name–don’t think of it as important), like this?\n\nroll2 &lt;- function() {\n  dice &lt;- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\n\nNow I’ll get an error when I run the function. The function needs the object bones to do its job, but there is no object named bones to be found (you can check by typing ls() which will show you the names in the environment, or memory).\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   object 'bones' not found\nYou can supply bones when you call roll2 if you make bones an argument of the function. To do this, put the name bones in the parentheses that follow function when you define roll2:\n\nroll2 &lt;- function(bones) {\n  dice &lt;- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\n\nNow roll2 will work as long as you supply bones when you call the function. You can take advantage of this to roll different types of dice each time you call roll2.\nRemember, we’re rolling pairs of dice:\n\nroll2(bones = 1:4)\n\n[1] 7\n\nroll2(bones = 1:6)\n\n[1] 5\n\nroll2(1:20)\n\n[1] 32\n\n\nNotice that roll2 will still give an error if you do not supply a value for the bones argument when you call roll2:\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   argument \"bones\" is missing, with no default\nYou can prevent this error by giving the bones argument a default value. To do this, set bones equal to a value when you define roll2:\n\nroll2 &lt;- function(bones = 1:6) {\n  dice &lt;- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\n\nNow you can supply a new value for bones if you like, and roll2 will use the default if you do not:\n\nroll2()\n\n[1] 9\n\n\nYou can give your functions as many arguments as you like. Just list their names, separated by commas, in the parentheses that follow function. When the function is run, R will replace each argument name in the function body with the value that the user supplies for the argument. If the user does not supply a value, R will replace the argument name with the argument’s default value (if you defined one).\nTo summarize, function helps you construct your own R functions. You create a body of code for your function to run by writing code between the braces that follow function. You create arguments for your function to use by supplying their names in the parentheses that follow function. Finally, you give your function a name by saving its output to an R object, as shown in Figure 4.6.\nOnce you’ve created your function, R will treat it like every other function in R. Think about how useful this is. Have you ever tried to create a new Excel option and add it to Microsoft’s menu bar? Or a new slide animation and add it to Powerpoint’s options? When you work with a programming language, you can do these types of things. As you learn to program in R, you will be able to create new, customized, reproducible tools for yourself whenever you like.\n\n\n\n\n\n\nFigure 4.6: “Every function in R has the same parts, and you can use function to create these parts. Assign the result to a name, so you can call the function later.”",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "r_basics.html#scripts",
    "href": "r_basics.html#scripts",
    "title": "4  Up and Running with R",
    "section": "4.6 Scripts",
    "text": "4.6 Scripts\nScripts are code that are saved for later reuse or editing. An R script is just a plain text file that you save R code in. You can open an R script in RStudio by going to File &gt; New File &gt; R script in the menu bar. RStudio will then open a fresh script above your console pane, as shown in Figure 4.7.\nI strongly encourage you to write and edit all of your R code in a script before you run it in the console. Why? This habit creates a reproducible record of your work. When you’re finished for the day, you can save your script and then use it to rerun your entire analysis the next day. Scripts are also very handy for editing and proofreading your code, and they make a nice copy of your work to share with others. To save a script, click the scripts pane, and then go to File &gt; Save As in the menu bar.\n\n\n\n\n\n\nFigure 4.7: “When you open an R Script (File &gt; New File &gt; R Script in the menu bar), RStudio creates a fourth pane (or puts a new tab in the existing pane) above the console where you can write and edit your code.”\n\n\n\nRStudio comes with many built-in features that make it easy to work with scripts. First, you can automatically execute a line of code in a script by clicking the Run button at the top of the editor panel.\nR will run whichever line of code your cursor is on. If you have a whole section highlighted, R will run the highlighted code. Alternatively, you can run the entire script by clicking the Source button. Don’t like clicking buttons? You can use Control + Return as a shortcut for the Run button. On Macs, that would be Command + Return.\nIf you’re not convinced about scripts, you soon will be. It becomes a pain to write multi-line code in the console’s single-line command line. Let’s avoid that headache and open your first script now before we move to the next chapter.\n\n\n\n\n\n\nTip\n\n\n\nExtract function\nRStudio comes with a tool that can help you build functions. To use it, highlight the lines of code in your R script that you want to turn into a function. Then click Code &gt; Extract Function in the menu bar. RStudio will ask you for a function name to use and then wrap your code in a function call. It will scan the code for undefined variables and use these as arguments.\nYou may want to double-check RStudio’s work. It assumes that your code is correct, so if it does something surprising, you may have a problem in your code.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "r_basics.html#summary",
    "href": "r_basics.html#summary",
    "title": "4  Up and Running with R",
    "section": "4.7 Summary",
    "text": "4.7 Summary\nWe’ve covered a lot of ground already. You now have a virtual die stored in your computer’s memory, as well as your own R function that rolls a pair of dice. You’ve also begun speaking the R language.\nThe two most important components of the R language are objects, which store data, and functions, which manipulate data. R also uses a host of operators like +, -, *, /, and &lt;- to do basic tasks. As a data scientist, you will use R objects to store data in your computer’s memory, and you will use functions to automate tasks and do complicated calculations.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "5  Packages",
    "section": "",
    "text": "5.1 Installing R packages\nR is a powerful language for data science and programming, allowing beginners and experts alike to manipulate, analyze, and visualize data effectively. One of the most appealing features of R is its extensive library of packages, which are essential tools for expanding its capabilities and streamlining the coding process.\nAn R package is a collection of reusable functions, datasets, and compiled code created by other users and developers to extend the functionality of the base R language. These packages cover a wide range of applications, such as data manipulation, statistical analysis, machine learning, and data visualization. By utilizing existing R packages, you can leverage the expertise of others and save time by avoiding the need to create custom functions from scratch.\nUsing others’ R packages is incredibly beneficial as it allows you to take advantage of the collective knowledge of the R community. Developers often create packages to address specific challenges, optimize performance, or implement popular algorithms or methodologies. By incorporating these packages into your projects, you can enhance your productivity, reduce development time, and ensure that you are using well-tested and reliable code.\nTo install an R package, you can use the install.packages() function in the R console or script. For example, to install the popular data manipulation package “dplyr,” simply type install.packages(“dplyr”). This command will download the package from the Comprehensive R Archive Network (CRAN) and install it on your local machine. Keep in mind that you only need to install a package once, unless you want to update it to a newer version.\nFor those who are going to be using R for bioinformatics or biological data science, you will also want to install packages from Bioconductor, which is a repository of R packages specifically designed for bioinformatics and computational biology. To install Bioconductor packages, you can use the BiocManager::install() function.\nTo use this recommended approach, you first need to install the BiocManager package, which is the package manager for Bioconductor.\ninstall.packages('BiocManager')\nThis is a one-time installation. After that, you can install any R, Bioconductor, rOpenSci, or even GitHub package using the BiocManager::install() function. For example, to install the ggplot2 package, which is widely used for data visualization, you would run:\nBiocManager::install(\"ggplot2\")",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#installing-vs-loading-library-r-packages",
    "href": "packages.html#installing-vs-loading-library-r-packages",
    "title": "5  Packages",
    "section": "5.2 Installing vs loading (library) R packages",
    "text": "5.2 Installing vs loading (library) R packages\nAfter installing an R package, you will need to load it into your R session before using its functions. To load a package, use the library() function followed by the package name, such as library(dplyr). Loading a package makes its functions and datasets available for use in your current R session. Note that you need to load a package every time you start a new R session.\n\nlibrary(ggplot2)\n\nNow, the functionality of the ggplot2 package is available in our R session.\n\n\n\n\n\n\nInstalling vs loading packages\n\n\n\nThe main thing to remember is that you only need to install a package once, but you need to load it with library each time you wish to use it in a new R session. R will unload all of its packages each time you close RStudio.\n\n\n\n\n\n\nFigure 5.1: Installing vs loading R packages.\n\n\n\nAs in {Figure 5.1}, screw in the lightbulb (eg., BiocManager::install) only once and then to use it, you need to turn on the switch each time you want to use it (library).",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#finding-r-packages",
    "href": "packages.html#finding-r-packages",
    "title": "5  Packages",
    "section": "5.3 Finding R packages",
    "text": "5.3 Finding R packages\nFinding useful R packages can be done in several ways. First, browsing CRAN (https://cran.r-project.org/) and Bioconductor (https://bioconductor.org) are an excellent starting points, as they host thousands of packages categorized by topic. Additionally, online forums like Stack Overflow and R-bloggers can provide valuable recommendations based on user experiences. Social media platforms such as Twitter, where developers and data scientists often share new packages and updates, can also be a helpful resource. Finally, don’t forget to ask your colleagues or fellow R users for their favorite packages, as they may have insights on which ones best suit your specific needs.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#creating-a-package",
    "href": "packages.html#creating-a-package",
    "title": "5  Packages",
    "section": "5.4 Creating a package",
    "text": "5.4 Creating a package\nWhile it may seem overwhelming, creating a package can be fairly simple with the assistance of R packages that provide tips and templates. devtools and biocthis are great starting points.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "reading_and_writing.html",
    "href": "reading_and_writing.html",
    "title": "6  Reading and writing data files",
    "section": "",
    "text": "6.1 Introduction\nIn this chapter, we will discuss how to read and write data files in R. Data files are essential for storing and sharing data across different platforms and applications. R provides a variety of functions and packages to read and write data files in different formats, such as text files, CSV files, Excel files. By mastering these functions, you can efficiently import and export data in R, enabling you to perform data analysis and visualization tasks effectively.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Reading and writing data files</span>"
    ]
  },
  {
    "objectID": "reading_and_writing.html#csv-files",
    "href": "reading_and_writing.html#csv-files",
    "title": "6  Reading and writing data files",
    "section": "6.2 CSV files",
    "text": "6.2 CSV files\nComma-Separated Values (CSV) files are a common file format for storing tabular data. They consist of rows and columns, with each row representing a record and each column representing a variable or attribute. CSV files are widely used for data storage and exchange due to their simplicity and compatibility with various software applications. In R, you can read and write CSV files using the read.csv() and write.csv() functions, respectively. A commonly used alternative is to use the readr package, which provides faster and more user-friendly functions for reading and writing CSV files.\n\n6.2.1 Writing a CSV file\nSince we are going to use the readr package, we need to install it first. You can install the readr package using the following command:\n\ninstall.packages(\"readr\")\n\nOnce the package is installed, you can load it into your R session using the library() function:\n\nlibrary(readr)\n\nSince we don’t have a CSV file sitting around, let’s create a simple data frame to write to a CSV file. Here’s an example data frame:\n\ndf &lt;- data.frame(\n  id = c(1, 2, 3, 4, 5),\n  name = c(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"),\n  age = c(25, 30, 35, 40, 45)\n)\n\nNow, you can write this data frame to a CSV file using the write_csv() function from the readr package. Here’s how you can do it:\n\nwrite_csv(df, \"data.csv\")\n\nYou can check the current working directory to see if the CSV file was created successfully. If you want to specify a different directory or file path, you can provide the full path in the write_csv() function.\n\n# see what the current working directory is\ngetwd()\n\n[1] \"/home/lorikern/Projects/Papers_Reporting_Conferences/RBiocBook-book/RPC519RBioc\"\n\n# and check to see that the file was created\ndir(pattern = \"data.csv\")\n\n[1] \"data.csv\"\n\n\n\n\n6.2.2 Reading a CSV file\nNow that we have a CSV file, let’s read it back into R using the read_csv() function from the readr package. Here’s how you can do it:\n\ndf2 &lt;- read_csv(\"data.csv\")\n\nRows: 5 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): name\ndbl (2): id, age\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nYou can check the structure of the data frame df2 to verify that the data was read correctly:\n\ndf2\n\n# A tibble: 5 × 3\n     id name      age\n  &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n1     1 Alice      25\n2     2 Bob        30\n3     3 Charlie    35\n4     4 David      40\n5     5 Eve        45\n\n\nThe readr package can read CSV files with various delimiters, headers, and data types, making it a versatile tool for handling tabular data in R. It can also read CSV files directly from web locations like so:\n\ndf3 &lt;- read_csv(\"https://data.cdc.gov/resource/pwn4-m3yp.csv\")\n\nRows: 1000 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (1): state\ndbl  (6): tot_cases, new_cases, tot_deaths, new_deaths, new_historic_cases, ...\ndttm (3): date_updated, start_date, end_date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThe dataset that you just downloaded is described here: Covid-19 data from CDC",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Reading and writing data files</span>"
    ]
  },
  {
    "objectID": "reading_and_writing.html#excel-files",
    "href": "reading_and_writing.html#excel-files",
    "title": "6  Reading and writing data files",
    "section": "6.3 Excel files",
    "text": "6.3 Excel files\nMicrosoft Excel files are another common file format for storing tabular data. Excel files can contain multiple sheets, formulas, and formatting options, making them a popular choice for data storage and analysis. In R, you can read and write Excel files using the readxl package. This package provides functions to import and export data from Excel files, enabling you to work with Excel data in R.\n\n6.3.1 Reading an Excel file\nTo read an Excel file in R, you need to install and load the readxl package. You can install the readxl package using the following command:\n\ninstall.packages(\"readxl\")\n\nOnce the package is installed, you can load it into your R session using the library() function:\n\nlibrary(readxl)\n\nNow, you can read an Excel file using the read_excel() function from the readxl package. We don’t have an excel file available, so let’s download one from the internet. Here’s an example:\n\ndownload.file('https://www.w3resource.com/python-exercises/pandas/excel/SaleData.xlsx', 'SaleData.xlsx')\n\nNow, you can read the Excel file into R using the read_excel() function:\n\ndf_excel &lt;- read_excel(\"SaleData.xlsx\")\n\nYou can check the structure of the data frame df_excel to verify that the data was read correctly:\n\ndf_excel\n\n# A tibble: 45 × 8\n   OrderDate           Region  Manager SalesMan  Item  Units Unit_price Sale_amt\n   &lt;dttm&gt;              &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n 1 2018-01-06 00:00:00 East    Martha  Alexander Tele…    95       1198   113810\n 2 2018-01-23 00:00:00 Central Hermann Shelli    Home…    50        500    25000\n 3 2018-02-09 00:00:00 Central Hermann Luis      Tele…    36       1198    43128\n 4 2018-02-26 00:00:00 Central Timothy David     Cell…    27        225     6075\n 5 2018-03-15 00:00:00 West    Timothy Stephen   Tele…    56       1198    67088\n 6 2018-04-01 00:00:00 East    Martha  Alexander Home…    60        500    30000\n 7 2018-04-18 00:00:00 Central Martha  Steven    Tele…    75       1198    89850\n 8 2018-05-05 00:00:00 Central Hermann Luis      Tele…    90       1198   107820\n 9 2018-05-22 00:00:00 West    Douglas Michael   Tele…    32       1198    38336\n10 2018-06-08 00:00:00 East    Martha  Alexander Home…    60        500    30000\n# ℹ 35 more rows\n\n\nThe readxl package provides various options to read Excel files with multiple sheets, specific ranges, and data types, making it a versatile tool for handling Excel data in R.\n\n\n6.3.2 Writing an Excel file\nTo write an Excel file in R, you can use the write_xlsx() function from the writexl package. You can install the writexl package using the following command:\n\ninstall.packages(\"writexl\")\n\nOnce the package is installed, you can load it into your R session using the library() function:\n\nlibrary(writexl)\n\nThe write_xlsx() function allows you to write a data frame to an Excel file. Here’s an example:\n\nwrite_xlsx(df, \"data.xlsx\")\n\nYou can check the current working directory to see if the Excel file was created successfully. If you want to specify a different directory or file path, you can provide the full path in the write_xlsx() function.\n\n# see what the current working directory is\ngetwd()\n\n[1] \"/home/lorikern/Projects/Papers_Reporting_Conferences/RBiocBook-book/RPC519RBioc\"\n\n# and check to see that the file was created\ndir(pattern = \"data.xlsx\")\n\n[1] \"data.xlsx\"",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Reading and writing data files</span>"
    ]
  },
  {
    "objectID": "reading_and_writing.html#additional-options",
    "href": "reading_and_writing.html#additional-options",
    "title": "6  Reading and writing data files",
    "section": "6.4 Additional options",
    "text": "6.4 Additional options\n\nGoogle Sheets: You can read and write data from Google Sheets using the googlesheets4 package. This package provides functions to interact with Google Sheets, enabling you to import and export data from Google Sheets to R.\nJSON files: You can read and write JSON files using the jsonlite package. This package provides functions to convert R objects to JSON format and vice versa, enabling you to work with JSON data in R.\nDatabase files: You can read and write data from database files using the DBI and RSQLite packages. These packages provide functions to interact with various database systems, enabling you to import and export data from databases to R.",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Reading and writing data files</span>"
    ]
  },
  {
    "objectID": "rproj_and_save_load.html",
    "href": "rproj_and_save_load.html",
    "title": "7  Saving and Loading Workspaces and Objects",
    "section": "",
    "text": "7.1 Rstudio Projects",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Saving and Loading Workspaces and Objects</span>"
    ]
  },
  {
    "objectID": "rproj_and_save_load.html#saving-and-loading-objects",
    "href": "rproj_and_save_load.html#saving-and-loading-objects",
    "title": "7  Saving and Loading Workspaces and Objects",
    "section": "7.2 Saving and Loading Objects",
    "text": "7.2 Saving and Loading Objects",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Saving and Loading Workspaces and Objects</span>"
    ]
  },
  {
    "objectID": "rproj_and_save_load.html#saving-and-loading-workspace",
    "href": "rproj_and_save_load.html#saving-and-loading-workspace",
    "title": "7  Saving and Loading Workspaces and Objects",
    "section": "7.3 Saving and Loading Workspace",
    "text": "7.3 Saving and Loading Workspace",
    "crumbs": [
      "Home",
      "Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Saving and Loading Workspaces and Objects</span>"
    ]
  },
  {
    "objectID": "data_structures_overview.html",
    "href": "data_structures_overview.html",
    "title": "R Data Structures",
    "section": "",
    "text": "Chapter overview\nWelcome to the section on R data structures! As you begin your journey in learning R, it is essential to understand the fundamental building blocks of this powerful programming language. R offers a variety of data structures to store and manipulate data, each with its unique properties and capabilities. In this section, we will cover the core data structures in R, including:\nBy the end of this section, you will have a solid understanding of these data structures, and you will be able to choose and utilize the appropriate data structure for your specific data manipulation and analysis tasks.\nIn each chapter, we will delve into the properties and usage of each data structure, starting with their definitions and moving on to their practical applications. We will provide examples, exercises, and active learning approaches to help you better understand and apply these concepts in your work.\nAs you progress through these chapters, practice the examples and exercises provided, engage in discussion, and collaborate with your peers to deepen your understanding of R data structures. This solid foundation will serve as the basis for more advanced data manipulation, analysis, and visualization techniques in R.",
    "crumbs": [
      "Home",
      "R Data Structures"
    ]
  },
  {
    "objectID": "data_structures_overview.html#chapter-overview",
    "href": "data_structures_overview.html#chapter-overview",
    "title": "R Data Structures",
    "section": "",
    "text": "Vectors\n\nIn this chapter, we will introduce you to the simplest data structure in R, the vector. We will cover how to create, access, and manipulate vectors, as well as discuss their unique properties and limitations.\n\n\n\nMatrices\n\nNext, we will explore matrices, which are two-dimensional data structures that extend vectors. You will learn how to create, access, and manipulate matrices, and understand their usefulness in mathematical operations and data organization.\n\n\n\nLists\n\nThe third chapter will focus on lists, a versatile data structure that can store elements of different types and sizes. We will discuss how to create, access, and modify lists, and demonstrate their flexibility in handling complex data structures.\n\n\n\nData.frames\n\nFinally, we will examine data.frames, a widely-used data structure for organizing and manipulating tabular data. You will learn how to create, access, and manipulate data.frames, and understand their advantages over other data structures for data analysis tasks.\n\n\n\nArrays\n\nWhile we will not focus directly on the array data type, which are multidimensional data structures that extend matrices, they are very similar to matrices, but with a third dimension.",
    "crumbs": [
      "Home",
      "R Data Structures"
    ]
  },
  {
    "objectID": "vectors.html",
    "href": "vectors.html",
    "title": "8  Vectors",
    "section": "",
    "text": "8.1 What is a Vector?\nA vector is the simplest and most basic data structure in R. It is a one-dimensional, ordered collection of elements, where all the elements are of the same data type. Vectors can store various types of data, such as numeric, character, or logical values. Figure 8.1 shows a pictorial representation of three vector examples.\nIn this chapter, we will provide a comprehensive overview of vectors, including how to create, access, and manipulate them. We will also discuss some unique properties and rules associated with vectors, and explore their applications in data analysis tasks.\nIn R, even a single value is a vector with length=1.\nz = 1\nz\n\n[1] 1\n\nlength(z)\n\n[1] 1\nIn the code above, we “assigned” the value 1 to the variable named z. Typing z by itself is an “expression” that returns a result which is, in this case, the value that we just assigned. The length method takes an R object and returns the R length. There are numerous ways of asking R about what an object represents, and length is one of them.\nVectors can contain numbers, strings (character data), or logical values (TRUE and FALSE) or other “atomic” data types Table 8.1. Vectors cannot contain a mix of types! We will introduce another data structure, the R list for situations when we need to store a mix of base R data types.",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#what-is-a-vector",
    "href": "vectors.html#what-is-a-vector",
    "title": "8  Vectors",
    "section": "",
    "text": "Figure 8.1: “Pictorial representation of three vector examples. The first vector is a numeric vector. The second is a ‘logical’ vector. The third is a character vector. Vectors also have indices and, optionally, names.”\n\n\n\n\n\n\n\n\n\n\n\nTable 8.1: Atomic (simplest) data types in R.\n\n\n\n\n\nData type\nStores\n\n\n\n\nnumeric\nfloating point numbers\n\n\ninteger\nintegers\n\n\ncomplex\ncomplex numbers\n\n\nfactor\ncategorical data\n\n\ncharacter\nstrings\n\n\nlogical\nTRUE or FALSE\n\n\nNA\nmissing\n\n\nNULL\nempty\n\n\nfunction\nfunction type",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#creating-vectors",
    "href": "vectors.html#creating-vectors",
    "title": "8  Vectors",
    "section": "8.2 Creating vectors",
    "text": "8.2 Creating vectors\nCharacter vectors (also sometimes called “string” vectors) are entered with each value surrounded by single or double quotes; either is acceptable, but they must match. They are always displayed by R with double quotes. Here are some examples of creating vectors:\n\n# examples of vectors\nc('hello','world')\n\n[1] \"hello\" \"world\"\n\nc(1,3,4,5,1,2)\n\n[1] 1 3 4 5 1 2\n\nc(1.12341e7,78234.126)\n\n[1] 11234100.00    78234.13\n\nc(TRUE,FALSE,TRUE,TRUE)\n\n[1]  TRUE FALSE  TRUE  TRUE\n\n# note how in the next case the TRUE is converted to \"TRUE\"\n# with quotes around it.\nc(TRUE,'hello')\n\n[1] \"TRUE\"  \"hello\"\n\n\nWe can also create vectors as “regular sequences” of numbers. For example:\n\n# create a vector of integers from 1 to 10\nx = 1:10\n# and backwards\nx = 10:1\n\nThe seq function can create more flexible regular sequences.\n\n# create a vector of numbers from 1 to 4 skipping by 0.3\ny = seq(1,4,0.3)\n\nAnd creating a new vector by concatenating existing vectors is possible, as well.\n\n# create a sequence by concatenating two other sequences\nz = c(y,x)\nz\n\n [1]  1.0  1.3  1.6  1.9  2.2  2.5  2.8  3.1  3.4  3.7  4.0 10.0  9.0  8.0  7.0\n[16]  6.0  5.0  4.0  3.0  2.0  1.0",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#vector-operations",
    "href": "vectors.html#vector-operations",
    "title": "8  Vectors",
    "section": "8.3 Vector Operations",
    "text": "8.3 Vector Operations\nOperations on a single vector are typically done element-by-element. For example, we can add 2 to a vector, 2 is added to each element of the vector and a new vector of the same length is returned.\n\nx = 1:10\nx + 2\n\n [1]  3  4  5  6  7  8  9 10 11 12\n\n\nIf the operation involves two vectors, the following rules apply. If the vectors are the same length: R simply applies the operation to each pair of elements.\n\nx + x\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\nIf the vectors are different lengths, but one length a multiple of the other, R reuses the shorter vector as needed.\n\nx = 1:10\ny = c(1,2)\nx * y\n\n [1]  1  4  3  8  5 12  7 16  9 20\n\n\nIf the vectors are different lengths, but one length not a multiple of the other, R reuses the shorter vector as needed and delivers a warning.\n\nx = 1:10\ny = c(2,3,4)\nx * y\n\nWarning in x * y: longer object length is not a multiple of shorter object\nlength\n\n\n [1]  2  6 12  8 15 24 14 24 36 20\n\n\nTypical operations include multiplication (“*”), addition, subtraction, division, exponentiation (“^”), but many operations in R operate on vectors and are then called “vectorized”.\n\n\n\n\n\n\nWarning\n\n\n\nBe aware of the recycling rule when working with vectors of different lengths, as it may lead to unexpected results if you’re not careful.",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#logical-vectors",
    "href": "vectors.html#logical-vectors",
    "title": "8  Vectors",
    "section": "8.4 Logical Vectors",
    "text": "8.4 Logical Vectors\nLogical vectors are vectors composed on only the values TRUE and FALSE. Note the all-upper-case and no quotation marks.\n\na = c(TRUE,FALSE,TRUE)\n\n# we can also create a logical vector from a numeric vector\n# 0 = false, everything else is 1\nb = c(1,0,217)\nd = as.logical(b)\nd\n\n[1]  TRUE FALSE  TRUE\n\n# test if a and d are the same at every element\nall.equal(a,d)\n\n[1] TRUE\n\n# We can also convert from logical to numeric\nas.numeric(a)\n\n[1] 1 0 1\n\n\n\n8.4.1 Logical Operators\nSome operators like &lt;, &gt;, ==, &gt;=, &lt;=, != can be used to create logical vectors.\n\n# create a numeric vector\nx = 1:10\n# testing whether x &gt; 5 creates a logical vector\nx &gt; 5\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nx &lt;= 5\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx != 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nx == 5\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nWe can also assign the results to a variable:\n\ny = (x == 5)\ny\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#indexing-vectors",
    "href": "vectors.html#indexing-vectors",
    "title": "8  Vectors",
    "section": "8.5 Indexing Vectors",
    "text": "8.5 Indexing Vectors\nIn R, an index is used to refer to a specific element or set of elements in an vector (or other data structure). [R uses [ and ] to perform indexing, although other approaches to getting subsets of larger data structures are common in R.\n\nx = seq(0,1,0.1)\n# create a new vector from the 4th element of x\nx[4]\n\n[1] 0.3\n\n\nWe can even use other vectors to perform the “indexing”.\n\nx[c(3,5,6)]\n\n[1] 0.2 0.4 0.5\n\ny = 3:6\nx[y]\n\n[1] 0.2 0.3 0.4 0.5\n\n\nCombining the concept of indexing with the concept of logical vectors results in a very power combination.\n\n# use help('rnorm') to figure out what is happening next\nmyvec = rnorm(10)\n\n# create logical vector that is TRUE where myvec is &gt;0.25\ngt1 = (myvec &gt; 0.25)\nsum(gt1)\n\n[1] 4\n\n# and use our logical vector to create a vector of myvec values that are &gt;0.25\nmyvec[gt1]\n\n[1] 1.3312651 0.6017431 0.3761033 0.4584445\n\n# or &lt;=0.25 using the logical \"not\" operator, \"!\"\nmyvec[!gt1]\n\n[1] -0.4385308 -0.5662789 -0.5151642 -0.1318329 -1.6637423 -0.4015470\n\n# shorter, one line approach\nmyvec[myvec &gt; 0.25]\n\n[1] 1.3312651 0.6017431 0.3761033 0.4584445",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#named-vectors",
    "href": "vectors.html#named-vectors",
    "title": "8  Vectors",
    "section": "8.6 Named Vectors",
    "text": "8.6 Named Vectors\nNamed vectors are vectors with labels or names assigned to their elements. These names can be used to access and manipulate the elements in a more meaningful way.\nTo create a named vector, use the names() function:\n\nfruit_prices &lt;- c(0.5, 0.75, 1.25)\nnames(fruit_prices) &lt;- c(\"apple\", \"banana\", \"cherry\")\nprint(fruit_prices)\n\n apple banana cherry \n  0.50   0.75   1.25 \n\n\nYou can also access and modify elements using their names:\n\nbanana_price &lt;- fruit_prices[\"banana\"]\nprint(banana_price)\n\nbanana \n  0.75 \n\nfruit_prices[\"apple\"] &lt;- 0.6\nprint(fruit_prices)\n\n apple banana cherry \n  0.60   0.75   1.25",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#character-vectors-a.k.a.-strings",
    "href": "vectors.html#character-vectors-a.k.a.-strings",
    "title": "8  Vectors",
    "section": "8.7 Character Vectors, A.K.A. Strings",
    "text": "8.7 Character Vectors, A.K.A. Strings\nR uses the paste function to concatenate strings.\n\npaste(\"abc\",\"def\")\n\n[1] \"abc def\"\n\npaste(\"abc\",\"def\",sep=\"THISSEP\")\n\n[1] \"abcTHISSEPdef\"\n\npaste0(\"abc\",\"def\")\n\n[1] \"abcdef\"\n\n## [1] \"abcdef\"\npaste(c(\"X\",\"Y\"),1:10)\n\n [1] \"X 1\"  \"Y 2\"  \"X 3\"  \"Y 4\"  \"X 5\"  \"Y 6\"  \"X 7\"  \"Y 8\"  \"X 9\"  \"Y 10\"\n\npaste(c(\"X\",\"Y\"),1:10,sep=\"_\")\n\n [1] \"X_1\"  \"Y_2\"  \"X_3\"  \"Y_4\"  \"X_5\"  \"Y_6\"  \"X_7\"  \"Y_8\"  \"X_9\"  \"Y_10\"\n\n\nWe can count the number of characters in a string.\n\nnchar('abc')\n\n[1] 3\n\nnchar(c('abc','d',123456))\n\n[1] 3 1 6\n\n\nPulling out parts of strings is also sometimes useful.\n\nsubstr('This is a good sentence.',start=10,stop=15)\n\n[1] \" good \"\n\n\nAnother common operation is to replace something in a string with something (a find-and-replace).\n\nsub('This','That','This is a good sentence.')\n\n[1] \"That is a good sentence.\"\n\n\nWhen we want to find all strings that match some other string, we can use grep, or “grab regular expression”.\n\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'))\n\n[1] 1 2 3\n\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'),value=TRUE)\n\n[1] \"abcdef\" \"abcd\"   \"bcde\"  \n\n\nRead about the grepl function (?grepl). Use that function to return a logical vector (TRUE/FALSE) for each entry above with an a in it.",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#missing-values-aka-na",
    "href": "vectors.html#missing-values-aka-na",
    "title": "8  Vectors",
    "section": "8.8 Missing Values, AKA “NA”",
    "text": "8.8 Missing Values, AKA “NA”\nR has a special value, “NA”, that represents a “missing” value, or Not Available, in a vector or other data structure. Here, we just create a vector to experiment.\n\nx = 1:5\nx\n\n[1] 1 2 3 4 5\n\nlength(x)\n\n[1] 5\n\n\n\nis.na(x)\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\nx[2] = NA\nx\n\n[1]  1 NA  3  4  5\n\n\nThe length of x is unchanged, but there is one value that is marked as “missing” by virtue of being NA.\n\nlength(x)\n\n[1] 5\n\nis.na(x)\n\n[1] FALSE  TRUE FALSE FALSE FALSE\n\n\nWe can remove NA values by using indexing. In the following, is.na(x) returns a logical vector the length of x. The ! is the logical NOT operator and converts TRUE to FALSE and vice-versa.\n\nx[!is.na(x)]\n\n[1] 1 3 4 5",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#exercises",
    "href": "vectors.html#exercises",
    "title": "8  Vectors",
    "section": "8.9 Exercises",
    "text": "8.9 Exercises\n\nCreate a numeric vector called temperatures containing the following values: 72, 75, 78, 81, 76, 73.\n\n\nShow answer\ntemperatures &lt;- c(72, 75, 78, 81, 76, 73, 93)\n\n\nCreate a character vector called days containing the following values: “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”, “Sunday”.\n\n\nShow answer\ndays &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\n\n\nCalculate the average temperature for the week and store it in a variable called average_temperature.\n\n\nShow answer\naverage_temperature &lt;- mean(temperatures)\n\n\nCreate a named vector called weekly_temperatures, where the names are the days of the week and the values are the temperatures from the temperatures vector.\n\n\nShow answer\nweekly_temperatures &lt;- temperatures\nnames(weekly_temperatures) &lt;- days\n\n\nCreate a numeric vector called ages containing the following values: 25, 30, 35, 40, 45, 50, 55, 60.\n\n\nShow answer\nages &lt;- c(25, 30, 35, 40, 45, 50, 55, 60)\n\n\nCreate a logical vector called is_adult by checking if the elements in the ages vector are greater than or equal to 18.\n\n\nShow answer\nis_adult &lt;- ages &gt;= 18\n\n\nCalculate the sum and product of the ages vector.\n\n\nShow answer\nsum_ages &lt;- sum(ages)\nproduct_ages &lt;- prod(ages)\n\n\nExtract the ages greater than or equal to 40 from the ages vector and store them in a variable called older_ages.\n\n\nShow answer\nolder_ages &lt;- ages[ages &gt;= 40]",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "matrices.html",
    "href": "matrices.html",
    "title": "9  Matrices",
    "section": "",
    "text": "9.1 Creating a matrix\nA matrix is a rectangular collection of the same data type (see Figure 9.1). It can be viewed as a collection of column vectors all of the same length and the same type (i.e. numeric, character or logical) OR a collection of row vectors, again all of the same type and length. A data.frame is also a rectangular array. All of the columns must be the same length, but they may be of different types. The rows and columns of a matrix or data frame can be given names. However these are implemented differently in R; many operations will work for one but not both, often a source of confusion.\nThere are many ways to create a matrix in R. One of the simplest is to use the matrix() function. In the code below, we’ll create a matrix from a vector from 1:16.\nmat1 &lt;- matrix(1:16,nrow=4)\nmat1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\nThe same is possible, but specifying that the matrix be “filled” by row.\nmat1 &lt;- matrix(1:16,nrow=4,byrow = TRUE)\nmat1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\nNotice the subtle difference in the order that the numbers go into the matrix.\nWe can also build a matrix from parts by “binding” vectors together:\nx &lt;- 1:10 \ny &lt;- rnorm(10)\nEach of the vectors above is of length 10 and both are “numeric”, so we can make them into a matrix. Using rbind binds rows (r) into a matrix.\nmat &lt;- rbind(x,y)\nmat\n\n       [,1]     [,2]       [,3]      [,4]     [,5]     [,6]        [,7]\nx  1.000000 2.000000  3.0000000 4.0000000 5.000000 6.000000 7.000000000\ny -1.325599 2.625988 -0.5995257 0.2640878 1.066886 1.026504 0.007406872\n       [,8]     [,9]     [,10]\nx 8.0000000 9.000000 10.000000\ny 0.9496984 1.374093  1.862218\nThe alternative to rbind is cbind that binds columns (c) together.\nmat &lt;- cbind(x,y)\nmat\n\n       x            y\n [1,]  1 -1.325598661\n [2,]  2  2.625987528\n [3,]  3 -0.599525738\n [4,]  4  0.264087823\n [5,]  5  1.066885781\n [6,]  6  1.026504421\n [7,]  7  0.007406872\n [8,]  8  0.949698364\n [9,]  9  1.374092714\n[10,] 10  1.862218163\nInspecting the names associated with rows and columns is often useful, particularly if the names have human meaning.\nrownames(mat)\n\nNULL\n\ncolnames(mat)\n\n[1] \"x\" \"y\"\nWe can also change the names of the matrix by assigning valid names to the columns or rows.\ncolnames(mat) = c('apples','oranges')\ncolnames(mat)\n\n[1] \"apples\"  \"oranges\"\n\nmat\n\n      apples      oranges\n [1,]      1 -1.325598661\n [2,]      2  2.625987528\n [3,]      3 -0.599525738\n [4,]      4  0.264087823\n [5,]      5  1.066885781\n [6,]      6  1.026504421\n [7,]      7  0.007406872\n [8,]      8  0.949698364\n [9,]      9  1.374092714\n[10,]     10  1.862218163\nMatrices have dimensions.\ndim(mat)\n\n[1] 10  2\n\nnrow(mat)\n\n[1] 10\n\nncol(mat)\n\n[1] 2",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#accessing-elements-of-a-matrix",
    "href": "matrices.html#accessing-elements-of-a-matrix",
    "title": "9  Matrices",
    "section": "9.2 Accessing elements of a matrix",
    "text": "9.2 Accessing elements of a matrix\nIndexing for matrices works as for vectors except that we now need to include both the row and column (in that order). We can access elements of a matrix using the square bracket [ indexing method. Elements can be accessed as var[r, c]. Here, r and c are vectors describing the elements of the matrix to select.\n\n\n\n\n\n\nImportant\n\n\n\nThe indices in R start with one, meaning that the first element of a vector or the first row/column of a matrix is indexed as one.\nThis is different from some other programming languages, such as Python, which use zero-based indexing, meaning that the first element of a vector or the first row/column of a matrix is indexed as zero.\nIt is important to be aware of this difference when working with data in R, especially if you are coming from a programming background that uses zero-based indexing. Using the wrong index can lead to unexpected results or errors in your code.\n\n\n\n# The 2nd element of the 1st row of mat\nmat[1,2]\n\n  oranges \n-1.325599 \n\n# The first ROW of mat\nmat[1,]\n\n   apples   oranges \n 1.000000 -1.325599 \n\n# The first COLUMN of mat\nmat[,1]\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n# and all elements of mat that are &gt; 4; note no comma\nmat[mat&gt;4]\n\n[1]  5  6  7  8  9 10\n\n## [1]  5  6  7  8  9 10\n\n\n\n\n\n\n\nCaution\n\n\n\nNote that in the last case, there is no “,”, so R treats the matrix as a long vector (length=20). This is convenient, sometimes, but it can also be a source of error, as some code may “work” but be doing something unexpected.\n\n\nWe can also use indexing to exclude a row or column by prefixing the selection with a - sign.\n\nmat[,-1]       # remove first column\n\n [1] -1.325598661  2.625987528 -0.599525738  0.264087823  1.066885781\n [6]  1.026504421  0.007406872  0.949698364  1.374092714  1.862218163\n\nmat[-c(1:5),]  # remove first five rows\n\n     apples     oranges\n[1,]      6 1.026504421\n[2,]      7 0.007406872\n[3,]      8 0.949698364\n[4,]      9 1.374092714\n[5,]     10 1.862218163",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#changing-values-in-a-matrix",
    "href": "matrices.html#changing-values-in-a-matrix",
    "title": "9  Matrices",
    "section": "9.3 Changing values in a matrix",
    "text": "9.3 Changing values in a matrix\nWe can create a matrix filled with random values drawn from a normal distribution for our work below.\n\nm = matrix(rnorm(20),nrow=10)\nsummary(m)\n\n       V1                V2         \n Min.   :-1.4939   Min.   :-1.2081  \n 1st Qu.:-0.9215   1st Qu.:-0.6468  \n Median :-0.1318   Median : 0.1367  \n Mean   :-0.0953   Mean   : 0.1488  \n 3rd Qu.: 0.3056   3rd Qu.: 0.5619  \n Max.   : 2.0916   Max.   : 2.4685  \n\n\nMultiplication and division works similarly to vectors. When multiplying by a vector, for example, the values of the vector are reused. In the simplest case, let’s multiply the matrix by a constant (vector of length 1).\n\n# multiply all values in the matrix by 20\nm2 = m*20\nsummary(m2)\n\n       V1                V2         \n Min.   :-29.879   Min.   :-24.161  \n 1st Qu.:-18.430   1st Qu.:-12.936  \n Median : -2.637   Median :  2.733  \n Mean   : -1.906   Mean   :  2.976  \n 3rd Qu.:  6.112   3rd Qu.: 11.239  \n Max.   : 41.833   Max.   : 49.370  \n\n\nBy combining subsetting with assignment, we can make changes to just part of a matrix.\n\n# and add 100 to the first column of m\nm2[,1] = m2[,1] + 100\n# summarize m\nsummary(m2)\n\n       V1               V2         \n Min.   : 70.12   Min.   :-24.161  \n 1st Qu.: 81.57   1st Qu.:-12.936  \n Median : 97.36   Median :  2.733  \n Mean   : 98.09   Mean   :  2.976  \n 3rd Qu.:106.11   3rd Qu.: 11.239  \n Max.   :141.83   Max.   : 49.370  \n\n\nA somewhat common transformation for a matrix is to transpose which changes rows to columns. One might need to do this if an assay output from a lab machine puts samples in rows and genes in columns, for example, while in Bioconductor/R, we often want the samples in columns and the genes in rows.\n\nt(m2)\n\n         [,1]      [,2]      [,3]       [,4]      [,5]       [,6]      [,7]\n[1,] 97.54502 70.121171 118.95653 141.832989 89.824526 105.547895  78.81841\n[2,] 13.11580  2.993531  49.36978   2.472511  5.607523  -6.200718 -15.18058\n          [,8]      [,9]     [,10]\n[1,] 106.30054  97.18116  74.81129\n[2,]  21.36702 -19.62368 -24.16138",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#calculations-on-matrix-rows-and-columns",
    "href": "matrices.html#calculations-on-matrix-rows-and-columns",
    "title": "9  Matrices",
    "section": "9.4 Calculations on matrix rows and columns",
    "text": "9.4 Calculations on matrix rows and columns\nAgain, we just need a matrix to play with. We’ll use rnorm again, but with a slight twist.\n\nm3 = matrix(rnorm(100,5,2),ncol=10) # what does the 5 mean here? And the 2?\n\nSince these data are from a normal distribution, we can look at a row (or column) to see what the mean and standard deviation are.\n\nmean(m3[,1])\n\n[1] 5.549797\n\nsd(m3[,1])\n\n[1] 1.541549\n\n# or a row\nmean(m3[1,])\n\n[1] 3.608359\n\nsd(m3[1,])\n\n[1] 1.647011\n\n\nThere are some useful convenience functions for computing means and sums of data in all of the columns and rows of matrices.\n\ncolMeans(m3)\n\n [1] 5.549797 4.505066 5.083448 4.682110 5.265026 5.246739 3.614876 5.350698\n [9] 5.049795 5.036546\n\nrowMeans(m3)\n\n [1] 3.608359 5.881085 5.650431 5.844686 4.932823 5.843897 4.052513 3.870038\n [9] 5.298616 4.401653\n\nrowSums(m3)\n\n [1] 36.08359 58.81085 56.50431 58.44686 49.32823 58.43897 40.52513 38.70038\n [9] 52.98616 44.01653\n\ncolSums(m3)\n\n [1] 55.49797 45.05066 50.83448 46.82110 52.65026 52.46739 36.14876 53.50698\n [9] 50.49795 50.36546\n\n\nWe can look at the distribution of column means:\n\n# save as a variable\ncmeans = colMeans(m3)\nsummary(cmeans)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  3.615   4.771   5.067   4.938   5.260   5.550 \n\n\nNote that this is centered pretty closely around the selected mean of 5 above.\nHow about the standard deviation? There is not a colSd function, but it turns out that we can easily apply functions that take vectors as input, like sd and “apply” them across either the rows (the first dimension) or columns (the second) dimension.\n\ncsds = apply(m3, 2, sd)\nsummary(csds)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.542   1.798   1.915   2.047   2.214   2.699 \n\n\nAgain, take a look at the distribution which is centered quite close to the selected standard deviation when we created our matrix.",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#exercises",
    "href": "matrices.html#exercises",
    "title": "9  Matrices",
    "section": "9.5 Exercises",
    "text": "9.5 Exercises\n\n9.5.1 Data preparation\nFor this set of exercises, we are going to rely on a dataset that comes with R. It gives the number of sunspots per month from 1749-1983. The dataset comes as a ts or time series data type which I convert to a matrix using the following code.\nJust run the code as is and focus on the rest of the exercises.\n\ndata(sunspots)\nsunspot_mat &lt;- matrix(as.vector(sunspots),ncol=12,byrow = TRUE)\ncolnames(sunspot_mat) &lt;- as.character(1:12)\nrownames(sunspot_mat) &lt;- as.character(1749:1983)\n\n\n\n9.5.2 Questions\n\nAfter the conversion above, what does sunspot_mat look like? Use functions to find the number of rows, the number of columns, the class, and some basic summary statistics.\n\n\nShow answer\nncol(sunspot_mat)\nnrow(sunspot_mat)\ndim(sunspot_mat)\nsummary(sunspot_mat)\nhead(sunspot_mat)\ntail(sunspot_mat)\n\n\nPractice subsetting the matrix a bit by selecting:\n\nThe first 10 years (rows)\nThe month of July (7th column)\nThe value for July, 1979 using the rowname to do the selection.\n\n\n\nShow answer\nsunspot_mat[1:10,]\nsunspot_mat[,7]\nsunspot_mat['1979',7]\n\n\n\n\nThese next few exercises take advantage of the fact that calling a univariate statistical function (one that expects a vector) works for matrices by just making a vector of all the values in the matrix. What is the highest (max) number of sunspots recorded in these data?\n\n\nShow answer\nmax(sunspot_mat)\n\n\nAnd the minimum?\n\n\nShow answer\nmin(sunspot_mat)\n\n\nAnd the overall mean and median?\n\n\nShow answer\nmean(sunspot_mat)\nmedian(sunspot_mat)\n\n\nUse the hist() function to look at the distribution of all the monthly sunspot data.\n\n\nShow answer\nhist(sunspot_mat)\n\n\nRead about the breaks argument to hist() to try to increase the number of breaks in the histogram to increase the resolution slightly. Adjust your hist() and breaks to your liking.\n\n\nShow answer\nhist(sunspot_mat, breaks=40)\n\n\nNow, let’s move on to summarizing the data a bit to learn about the pattern of sunspots varies by month or by year. Examine the dataset again. What do the columns represent? And the rows?\n\n\nShow answer\n# just a quick glimpse of the data will give us a sense\nhead(sunspot_mat)\n\n\nWe’d like to look at the distribution of sunspots by month. How can we do that?\n\n\nShow answer\n# the mean of the columns is the mean number of sunspots per month.\ncolMeans(sunspot_mat)\n\n# Another way to write the same thing:\napply(sunspot_mat, 2, mean)\n\n\nAssign the month summary above to a variable and summarize it to get a sense of the spread over months.\n\n\nShow answer\nmonthmeans = colMeans(sunspot_mat)\nsummary(monthmeans)\n\n\nPlay the same game for years to get the per-year mean?\n\n\nShow answer\nymeans = rowMeans(sunspot_mat)\nsummary(ymeans)\n\n\nMake a plot of the yearly means. Do you see a pattern?\n\n\nShow answer\nplot(ymeans)\n# or make it clearer\nplot(ymeans, type='l')",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "lists.html",
    "href": "lists.html",
    "title": "10  Lists",
    "section": "",
    "text": "10.1 The Power of a “Catch-All” Container\nSo far in our journey through R’s data structures, we’ve dealt with vectors and matrices. These are fantastic tools, but they have one strict rule: all their elements must be of the same data type. You can have a vector of numbers or a matrix of characters, but you can’t mix and match.\nBut what about real-world biological data? A single experiment can generate a dizzying variety of information. Imagine you’re studying a particular gene. You might have:\nHow could you possibly store all of this related, yet different, information together? You could create many separate variables, but that would be clunky and hard to manage. This is exactly the problem that lists are designed to solve.\nA list in R is like a flexible, multi-compartment container. It’s a single object that can hold a collection of other R objects, and those objects can be of any type, length, or dimension. You can put vectors, matrices, logical values, and even other lists inside a single list. This makes them one of the most fundamental and powerful data structures for bioinformatics analysis.\nThe key features of lists are:",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "lists.html#the-power-of-a-catch-all-container",
    "href": "lists.html#the-power-of-a-catch-all-container",
    "title": "10  Lists",
    "section": "",
    "text": "The gene’s name (text).\nIts expression level across several samples (a set of numbers).\nA record of whether it’s a known cancer-related gene (a simple TRUE/FALSE).\nThe raw fluorescence values from your qPCR machine (a matrix of numbers).\nSome personal notes about the experiment (a paragraph of text).\n\n\n\n\n\nFlexibility: They can contain a mix of any data type.\nOrganization: You can and should name the elements of a list, making your data self-describing.\nHierarchy: Because lists can contain other lists, you can create complex, nested data structures to represent sophisticated relationships in your data.",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "lists.html#creating-a-list",
    "href": "lists.html#creating-a-list",
    "title": "10  Lists",
    "section": "10.2 Creating a List",
    "text": "10.2 Creating a List\nYou create a list with the list() function. The best practice is to name the elements as you create them. This makes your code infinitely more readable and your data easier to work with.\nLet’s create a list to store the information for our hypothetical gene study.\n\n# An experiment tracking list for the gene TP53\nexperiment_data &lt;- list(\n  experiment_id = \"EXP042\",\n  gene_name = \"TP53\",\n  read_counts = c(120, 155, 98, 210),\n  is_control = FALSE,\n  sample_matrix = matrix(1:4, nrow = 2, dimnames = list(c(\"Treated\", \"Untreated\"), c(\"Replicate1\", \"Replicate2\")))\n)\n\n# --- Function Explainer: print() ---\n# The print() function displays the contents of an R object in the console. \n# For a list, it shows each element and its contents. It's the default action \n# when you just type the variable's name and hit Enter.\nprint(experiment_data)\n\n$experiment_id\n[1] \"EXP042\"\n\n$gene_name\n[1] \"TP53\"\n\n$read_counts\n[1] 120 155  98 210\n\n$is_control\n[1] FALSE\n\n$sample_matrix\n          Replicate1 Replicate2\nTreated            1          3\nUntreated          2          4",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "lists.html#inspecting-your-list-whats-inside",
    "href": "lists.html#inspecting-your-list-whats-inside",
    "title": "10  Lists",
    "section": "10.3 Inspecting Your List: What’s Inside?",
    "text": "10.3 Inspecting Your List: What’s Inside?\nWhen someone hands you a tube in the lab, the first thing you do is look at the label. When R gives you a complex object like a list, you need to do the same. R provides several “introspection” functions to help you understand the contents and structure of your lists.\n\n10.3.1 str(): The Structure Function\nThis is arguably the most useful function for inspecting any R object, especially lists.\n\n# --- Function Explainer: str() ---\n# The str() function provides a compact, human-readable summary of an \n# object's internal \"str\"ucture. It's your best friend for understanding \n# what's inside a list, including the type and a preview of each element.\nstr(experiment_data)\n\nList of 5\n $ experiment_id: chr \"EXP042\"\n $ gene_name    : chr \"TP53\"\n $ read_counts  : num [1:4] 120 155 98 210\n $ is_control   : logi FALSE\n $ sample_matrix: int [1:2, 1:2] 1 2 3 4\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:2] \"Treated\" \"Untreated\"\n  .. ..$ : chr [1:2] \"Replicate1\" \"Replicate2\"\n\n\nThe output of str() tells us everything we need to know: it’s a “List of 5”, and for each of the 5 elements, it shows the name (e.g., experiment_id), the data type (e.g., chr for character, num for numeric), and a preview of the content.\n\n\n10.3.2 length(), names(), and class()\nThese functions give you more specific information about the list itself.\n\n# --- Function Explainer: length() ---\n# For a list, length() tells you how many top-level elements it contains.\nlength(experiment_data)\n\n[1] 5\n\n# --- Function Explainer: names() ---\n# The names() function extracts the names of the elements in a list as a \n# character vector. It's a great way to see what you can access.\nnames(experiment_data)\n\n[1] \"experiment_id\" \"gene_name\"     \"read_counts\"   \"is_control\"   \n[5] \"sample_matrix\"\n\n# --- Function Explainer: class() ---\n# The class() function tells you the type of the object itself. \n# This is useful to confirm you are indeed working with a list.\nclass(experiment_data)\n\n[1] \"list\"",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "lists.html#accessing-list-elements-getting-things-out",
    "href": "lists.html#accessing-list-elements-getting-things-out",
    "title": "10  Lists",
    "section": "10.4 Accessing List Elements: Getting Things Out",
    "text": "10.4 Accessing List Elements: Getting Things Out\nOkay, you’ve packed your experimental data into a list. Now, how do you get specific items out? This is a critical concept, and R has a few ways to do it, each with a distinct purpose.\n\n10.4.1 The Mighty [[...]] and $ for Single Items\nTo pull out a single element from a list in its original form, you use either double square brackets [[...]] or the dollar sign $ (for named lists). Think of this as carefully reaching into a specific compartment of your container and taking out the item itself.\nLet’s use our experiment_data list.\n\n# Get the gene name using [[...]]\ngene &lt;- experiment_data[[\"gene_name\"]]\nprint(gene)\n\n[1] \"TP53\"\n\nclass(gene) # It's a character vector, just as it was when we put it in.\n\n[1] \"character\"\n\n# Get the read counts using the $ shortcut. This is often easier to read.\nreads &lt;- experiment_data$read_counts\nprint(reads)\n\n[1] 120 155  98 210\n\nclass(reads) # It's a numeric vector.\n\n[1] \"numeric\"\n\n# The [[...]] has a neat trick: you can use a variable to specify the name.\nelement_to_get &lt;- \"read_counts\"\nexperiment_data[[element_to_get]]\n\n[1] 120 155  98 210\n\n\nThe key takeaway is that [[...]] and $ extract the element. The result is the object that was stored inside the list.\n\n\n10.4.2 The Subsetting [...] for New Lists\nThe single square bracket [...] behaves differently. It always returns a new, smaller list that is a subset of the original list. It’s like taking a whole compartment, label and all, out of your larger container.\n\n# Get the gene name using [...]\ngene_sublist &lt;- experiment_data[\"gene_name\"]\n\nprint(gene_sublist)\n\n$gene_name\n[1] \"TP53\"\n\n# --- Note the class! ---\n# The result is another list, which contains the gene_name element.\nclass(gene_sublist) \n\n[1] \"list\"\n\n\nThis distinction is vital. If you want to perform a calculation on an element (like finding the mean() of read_counts), you must extract it with [[...]] or $. If you tried mean(experiment_data[\"read_counts\"]), R would give you an error because you can’t calculate the mean of a list!",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "lists.html#modifying-lists",
    "href": "lists.html#modifying-lists",
    "title": "10  Lists",
    "section": "10.5 Modifying Lists",
    "text": "10.5 Modifying Lists\nYour data is rarely static. You can easily add, remove, or update elements in a list after you’ve created it.\n\n10.5.1 Adding and Updating Elements\nYou can add a new element or change an existing one by using the $ or [[...]] assignment syntax.\n\n# Add the date of the experiment\nexperiment_data$date &lt;- \"2024-06-05\"\n\n# Add some notes using the [[...]] syntax\nexperiment_data[[\"notes\"]] &lt;- \"Initial pilot experiment. High variance in read counts.\"\n\n# Let's update the control status\nexperiment_data$is_control &lt;- TRUE\n\n# Let's look at the structure now\nstr(experiment_data)\n\nList of 7\n $ experiment_id: chr \"EXP042\"\n $ gene_name    : chr \"TP53\"\n $ read_counts  : num [1:4] 120 155 98 210\n $ is_control   : logi TRUE\n $ sample_matrix: int [1:2, 1:2] 1 2 3 4\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:2] \"Treated\" \"Untreated\"\n  .. ..$ : chr [1:2] \"Replicate1\" \"Replicate2\"\n $ date         : chr \"2024-06-05\"\n $ notes        : chr \"Initial pilot experiment. High variance in read counts.\"\n\n\n\n\n10.5.2 Removing Elements\nTo remove an element from a list, you simply assign NULL to it. NULL is R’s special object representing nothingness.\n\n# We've decided the matrix isn't needed for this summary object.\nexperiment_data$sample_matrix &lt;- NULL\n\n# See the final structure of our list\nstr(experiment_data)\n\nList of 6\n $ experiment_id: chr \"EXP042\"\n $ gene_name    : chr \"TP53\"\n $ read_counts  : num [1:4] 120 155 98 210\n $ is_control   : logi TRUE\n $ date         : chr \"2024-06-05\"\n $ notes        : chr \"Initial pilot experiment. High variance in read counts.\"",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "lists.html#a-biological-example-a-self-contained-gene-record",
    "href": "lists.html#a-biological-example-a-self-contained-gene-record",
    "title": "10  Lists",
    "section": "10.6 A Biological Example: A Self-Contained Gene Record",
    "text": "10.6 A Biological Example: A Self-Contained Gene Record\nLet’s put this all together. Lists are perfect for creating self-contained records that you can easily pass to functions or combine into larger lists.\n\n# --- Function Explainer: log2() ---\n# The log2() function calculates the base-2 logarithm. It's very common in \n# gene expression analysis to transform skewed count data to make it more \n# symmetric and easier to model.\n\nbrca1_gene &lt;- list(\n  gene_symbol = \"BRCA1\",\n  full_name = \"BRCA1 DNA repair associated\",\n  chromosome = \"17\",\n  expression_log2 = log2(c(45, 50, 30, 88, 120)),\n  related_diseases = c(\"Breast Cancer\", \"Ovarian Cancer\")\n)\n\n# Now we can easily work with this structured information\n\n# --- Function Explainer: cat() ---\n# The cat() function concatenates and prints its arguments to the console.\n# Unlike print(), it allows you to seamlessly join text and variables, and \n# the \"\\n\" character is used to add a newline (a line break).\ncat(\"Analyzing gene:\", brca1_gene$gene_symbol, \"\\n\")\n\nAnalyzing gene: BRCA1 \n\ncat(\"Located on chromosome:\", brca1_gene$chromosome, \"\\n\")\n\nLocated on chromosome: 17 \n\n# Calculate the average log2 expression\n# --- Function Explainer: mean() ---\n# The mean() function calculates the arithmetic average of a numeric vector.\navg_expression &lt;- mean(brca1_gene$expression_log2)\ncat(\"Average log2 expression:\", avg_expression, \"\\n\")\n\nAverage log2 expression: 5.881784 \n\n\nThis simple brca1_gene list is now a complete, portable record. You could imagine creating a list of these gene records, creating a powerful, hierarchical database for your entire project.",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html",
    "href": "dataframes_intro.html",
    "title": "11  Data Frames",
    "section": "",
    "text": "11.1 Learning goals\nWhile R has many different data types, the one that is central to much of the power and popularity of R is the data.frame. A data.frame looks a bit like an R matrix in that it has two dimensions, rows and columns. However, data.frames are usually viewed as a set of columns representing variables and the rows representing the values of those variables. Importantly, a data.frame may contain different data types in each of its columns; matrices must contain only one data type. This distinction is important to remember, as there are specific approaches to working with R data.frames that may be different than those for working with matrices.",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#learning-goals",
    "href": "dataframes_intro.html#learning-goals",
    "title": "11  Data Frames",
    "section": "",
    "text": "Understand how data.frames are different from matrices.\nKnow a few functions for examing the contents of a data.frame.\nList approaches for subsetting data.frames.\nBe able to load and save tabular data from and to disk.\nShow how to create a data.frames from scratch.",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#learning-objectives",
    "href": "dataframes_intro.html#learning-objectives",
    "title": "11  Data Frames",
    "section": "11.2 Learning objectives",
    "text": "11.2 Learning objectives\n\nLoad the yeast growth dataset into R using read.csv.\nExamine the contents of the dataset.\nUse subsetting to find genes that may be involved with nutrient metabolism and transport.\nSummarize data measurements by categories.",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#dataset",
    "href": "dataframes_intro.html#dataset",
    "title": "11  Data Frames",
    "section": "11.3 Dataset",
    "text": "11.3 Dataset\nThe data used here are borrowed directly from the fantastic Bioconnector tutorials and are a cleaned up version of the data from Brauer et al. Coordination of Growth Rate, Cell Cycle, Stress Response, and Metabolic Activity in Yeast (2008) Mol Biol Cell 19:352-367. These data are from a gene expression microarray, and in this paper the authors examine the relationship between growth rate and gene expression in yeast cultures limited by one of six different nutrients (glucose, leucine, ammonium, sulfate, phosphate, uracil). If you give yeast a rich media loaded with nutrients except restrict the supply of a single nutrient, you can control the growth rate to any rate you choose. By starving yeast of specific nutrients you can find genes that:\n\nRaise or lower their expression in response to growth rate. Growth-rate dependent expression patterns can tell us a lot about cell cycle control, and how the cell responds to stress. The authors found that expression of &gt;25% of all yeast genes is linearly correlated with growth rate, independent of the limiting nutrient. They also found that the subset of negatively growth-correlated genes is enriched for peroxisomal functions, and positively correlated genes mainly encode ribosomal functions.\nRespond differently when different nutrients are being limited. If you see particular genes that respond very differently when a nutrient is sharply restricted, these genes might be involved in the transport or metabolism of that specific nutrient.\n\nThe dataset can be downloaded directly from:\n\nbrauer2007_tidy.csv\n\nWe are going to read this dataset into R and then use it as a playground for learning about data.frames.",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#reading-in-data",
    "href": "dataframes_intro.html#reading-in-data",
    "title": "11  Data Frames",
    "section": "11.4 Reading in data",
    "text": "11.4 Reading in data\nR has many capabilities for reading in data. Many of the functions have names that help us to understand what data format is to be expected. In this case, the filename that we want to read ends in .csv, meaning comma-separated-values. The read.csv() function reads in .csv files. As usual, it is worth reading help('read.csv') to get a better sense of the possible bells-and-whistles.\nThe read.csv() function can read directly from a URL, so we do not need to download the file directly. This dataset is relatively large (about 16MB), so this may take a bit depending on your network connection speed.\n\noptions(width=60)\n\n\nurl = paste0(\n    'https://raw.githubusercontent.com',\n    '/bioconnector/workshops/master/data/brauer2007_tidy.csv'\n)\nydat &lt;- read.csv(url)\n\nOur variable, ydat, now “contains” the downloaded and read data. We can check to see what data type read.csv gave us:\n\nclass(ydat)\n\n[1] \"data.frame\"",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#inspecting-data.frames",
    "href": "dataframes_intro.html#inspecting-data.frames",
    "title": "11  Data Frames",
    "section": "11.5 Inspecting data.frames",
    "text": "11.5 Inspecting data.frames\nOur ydat variable is a data.frame. As I mentioned, the dataset is fairly large, so we will not be able to look at it all at once on the screen. However, R gives us many tools to inspect a data.frame.\n\nOverviews of content\n\nhead() to show first few rows\ntail() to show last few rows\n\nSize\n\ndim() for dimensions (rows, columns)\nnrow()\nncol()\nobject.size() for power users interested in the memory used to store an object\n\nData and attribute summaries\n\ncolnames() to get the names of the columns\nrownames() to get the “names” of the rows–may not be present\nsummary() to get per-column summaries of the data in the data.frame.\n\n\n\nhead(ydat)\n\n  symbol systematic_name nutrient rate expression\n1   SFB2         YNL049C  Glucose 0.05      -0.24\n2   &lt;NA&gt;         YNL095C  Glucose 0.05       0.28\n3   QRI7         YDL104C  Glucose 0.05      -0.02\n4   CFT2         YLR115W  Glucose 0.05      -0.33\n5   SSO2         YMR183C  Glucose 0.05       0.05\n6   PSP2         YML017W  Glucose 0.05      -0.69\n                            bp\n1        ER to Golgi transport\n2   biological process unknown\n3 proteolysis and peptidolysis\n4      mRNA polyadenylylation*\n5              vesicle fusion*\n6   biological process unknown\n                             mf\n1    molecular function unknown\n2    molecular function unknown\n3 metalloendopeptidase activity\n4                   RNA binding\n5              t-SNARE activity\n6    molecular function unknown\n\ntail(ydat)\n\n       symbol systematic_name nutrient rate expression\n198425   DOA1         YKL213C   Uracil  0.3       0.14\n198426   KRE1         YNL322C   Uracil  0.3       0.28\n198427   MTL1         YGR023W   Uracil  0.3       0.27\n198428   KRE9         YJL174W   Uracil  0.3       0.43\n198429   UTH1         YKR042W   Uracil  0.3       0.19\n198430   &lt;NA&gt;         YOL111C   Uracil  0.3       0.04\n                                               bp\n198425    ubiquitin-dependent protein catabolism*\n198426      cell wall organization and biogenesis\n198427      cell wall organization and biogenesis\n198428     cell wall organization and biogenesis*\n198429 mitochondrion organization and biogenesis*\n198430                 biological process unknown\n                                        mf\n198425          molecular function unknown\n198426 structural constituent of cell wall\n198427          molecular function unknown\n198428          molecular function unknown\n198429          molecular function unknown\n198430          molecular function unknown\n\ndim(ydat)\n\n[1] 198430      7\n\nnrow(ydat)\n\n[1] 198430\n\nncol(ydat)\n\n[1] 7\n\ncolnames(ydat)\n\n[1] \"symbol\"          \"systematic_name\" \"nutrient\"       \n[4] \"rate\"            \"expression\"      \"bp\"             \n[7] \"mf\"             \n\nsummary(ydat)\n\n    symbol          systematic_name      nutrient        \n Length:198430      Length:198430      Length:198430     \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n                                                         \n                                                         \n                                                         \n      rate          expression             bp           \n Min.   :0.0500   Min.   :-6.500000   Length:198430     \n 1st Qu.:0.1000   1st Qu.:-0.290000   Class :character  \n Median :0.2000   Median : 0.000000   Mode  :character  \n Mean   :0.1752   Mean   : 0.003367                     \n 3rd Qu.:0.2500   3rd Qu.: 0.290000                     \n Max.   :0.3000   Max.   : 6.640000                     \n      mf           \n Length:198430     \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n\n\nIn RStudio, there is an additional function, View() (note the capital “V”) that opens the first 1000 rows (default) in the RStudio window, akin to a spreadsheet view.\n\nView(ydat)",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#accessing-variables-columns-and-subsetting",
    "href": "dataframes_intro.html#accessing-variables-columns-and-subsetting",
    "title": "11  Data Frames",
    "section": "11.6 Accessing variables (columns) and subsetting",
    "text": "11.6 Accessing variables (columns) and subsetting\nIn R, data.frames can be subset similarly to other two-dimensional data structures. The [ in R is used to denote subsetting of any kind. When working with two-dimensional data, we need two values inside the [ ] to specify the details. The specification is [rows, columns]. For example, to get the first three rows of ydat, use:\n\nydat[1:3, ]\n\n  symbol systematic_name nutrient rate expression\n1   SFB2         YNL049C  Glucose 0.05      -0.24\n2   &lt;NA&gt;         YNL095C  Glucose 0.05       0.28\n3   QRI7         YDL104C  Glucose 0.05      -0.02\n                            bp\n1        ER to Golgi transport\n2   biological process unknown\n3 proteolysis and peptidolysis\n                             mf\n1    molecular function unknown\n2    molecular function unknown\n3 metalloendopeptidase activity\n\n\nNote how the second number, the columns, is blank. R takes that to mean “all the columns”. Similarly, we can combine rows and columns specification arbitrarily.\n\nydat[1:3, 1:3]\n\n  symbol systematic_name nutrient\n1   SFB2         YNL049C  Glucose\n2   &lt;NA&gt;         YNL095C  Glucose\n3   QRI7         YDL104C  Glucose\n\n\nBecause selecting a single variable, or column, is such a common operation, there are two shortcuts for doing so with data.frames. The first, the $ operator works like so:\n\n# Look at the column names, just to refresh memory\ncolnames(ydat)\n\n[1] \"symbol\"          \"systematic_name\" \"nutrient\"       \n[4] \"rate\"            \"expression\"      \"bp\"             \n[7] \"mf\"             \n\n# Note that I am using \"head\" here to limit the output\nhead(ydat$symbol)\n\n[1] \"SFB2\" NA     \"QRI7\" \"CFT2\" \"SSO2\" \"PSP2\"\n\n# What is the actual length of \"symbol\"?\nlength(ydat$symbol)\n\n[1] 198430\n\n\nThe second is related to the fact that, in R, data.frames are also lists. We subset a list by using [[]] notation. To get the second column of ydat, we can use:\n\nhead(ydat[[2]])\n\n[1] \"YNL049C\" \"YNL095C\" \"YDL104C\" \"YLR115W\" \"YMR183C\"\n[6] \"YML017W\"\n\n\nAlternatively, we can use the column name:\n\nhead(ydat[[\"systematic_name\"]])\n\n[1] \"YNL049C\" \"YNL095C\" \"YDL104C\" \"YLR115W\" \"YMR183C\"\n[6] \"YML017W\"\n\n\n\n11.6.1 Some data exploration\nThere are a couple of columns that include numeric values. Which columns are numeric?\n\nclass(ydat$symbol)\n\n[1] \"character\"\n\nclass(ydat$rate)\n\n[1] \"numeric\"\n\nclass(ydat$expression)\n\n[1] \"numeric\"\n\n\nMake histograms of: - the expression values - the rate values\nWhat does the table() function do? Could you use that to look a the rate column given that that column appears to have repeated values?\nWhat rate corresponds to the most nutrient-starved condition?\n\n\n11.6.2 More advanced indexing and subsetting\nWe can use, for example, logical values (TRUE/FALSE) to subset data.frames.\n\nhead(ydat[ydat$symbol == 'LEU1', ])\n\n     symbol systematic_name nutrient rate expression   bp\nNA     &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA &lt;NA&gt;\nNA.1   &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA &lt;NA&gt;\nNA.2   &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA &lt;NA&gt;\nNA.3   &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA &lt;NA&gt;\nNA.4   &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA &lt;NA&gt;\nNA.5   &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA &lt;NA&gt;\n       mf\nNA   &lt;NA&gt;\nNA.1 &lt;NA&gt;\nNA.2 &lt;NA&gt;\nNA.3 &lt;NA&gt;\nNA.4 &lt;NA&gt;\nNA.5 &lt;NA&gt;\n\ntail(ydat[ydat$symbol == 'LEU1', ])\n\n         symbol systematic_name nutrient rate expression\nNA.47244   &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA\nNA.47245   &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA\nNA.47246   &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA\nNA.47247   &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA\nNA.47248   &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA\nNA.47249   &lt;NA&gt;            &lt;NA&gt;     &lt;NA&gt;   NA         NA\n           bp   mf\nNA.47244 &lt;NA&gt; &lt;NA&gt;\nNA.47245 &lt;NA&gt; &lt;NA&gt;\nNA.47246 &lt;NA&gt; &lt;NA&gt;\nNA.47247 &lt;NA&gt; &lt;NA&gt;\nNA.47248 &lt;NA&gt; &lt;NA&gt;\nNA.47249 &lt;NA&gt; &lt;NA&gt;\n\n\nWhat is the problem with this approach? It appears that there are a bunch of NA values. Taking a quick look at the symbol column, we see what the problem.\n\nsummary(ydat$symbol)\n\n   Length     Class      Mode \n   198430 character character \n\n\nUsing the is.na() function, we can make filter further to get down to values of interest.\n\nhead(ydat[ydat$symbol == 'LEU1' & !is.na(ydat$symbol), ])\n\n      symbol systematic_name nutrient rate expression\n1526    LEU1         YGL009C  Glucose 0.05      -1.12\n7043    LEU1         YGL009C  Glucose 0.10      -0.77\n12555   LEU1         YGL009C  Glucose 0.15      -0.67\n18071   LEU1         YGL009C  Glucose 0.20      -0.59\n23603   LEU1         YGL009C  Glucose 0.25      -0.20\n29136   LEU1         YGL009C  Glucose 0.30       0.03\n                        bp\n1526  leucine biosynthesis\n7043  leucine biosynthesis\n12555 leucine biosynthesis\n18071 leucine biosynthesis\n23603 leucine biosynthesis\n29136 leucine biosynthesis\n                                          mf\n1526  3-isopropylmalate dehydratase activity\n7043  3-isopropylmalate dehydratase activity\n12555 3-isopropylmalate dehydratase activity\n18071 3-isopropylmalate dehydratase activity\n23603 3-isopropylmalate dehydratase activity\n29136 3-isopropylmalate dehydratase activity\n\n\nSometimes, looking at the data themselves is not that important. Using dim() is one possibility to look at the number of rows and columns after subsetting.\n\ndim(ydat[ydat$expression &gt; 3, ])\n\n[1] 714   7\n\n\nFind the high expressed genes when leucine-starved. For this task we can also use subset which allows us to treat column names as R variables (no $ needed).\n\nsubset(ydat, nutrient == 'Leucine' & rate == 0.05 & expression &gt; 3)\n\n       symbol systematic_name nutrient rate expression\n133768   QDR2         YIL121W  Leucine 0.05       4.61\n133772   LEU1         YGL009C  Leucine 0.05       3.84\n133858   BAP3         YDR046C  Leucine 0.05       4.29\n135186   &lt;NA&gt;         YPL033C  Leucine 0.05       3.43\n135187   &lt;NA&gt;         YLR267W  Leucine 0.05       3.23\n135288   HXT3         YDR345C  Leucine 0.05       5.16\n135963   TPO2         YGR138C  Leucine 0.05       3.75\n135965   YRO2         YBR054W  Leucine 0.05       4.40\n136102   GPG1         YGL121C  Leucine 0.05       3.08\n136109  HSP42         YDR171W  Leucine 0.05       3.07\n136119   HXT5         YHR096C  Leucine 0.05       4.90\n136151   &lt;NA&gt;         YJL144W  Leucine 0.05       3.06\n136152   MOH1         YBL049W  Leucine 0.05       3.43\n136153   &lt;NA&gt;         YBL048W  Leucine 0.05       3.95\n136189  HSP26         YBR072W  Leucine 0.05       4.86\n136231   NCA3         YJL116C  Leucine 0.05       4.03\n136233   &lt;NA&gt;         YBR116C  Leucine 0.05       3.28\n136486   &lt;NA&gt;         YGR043C  Leucine 0.05       3.07\n137443   ADH2         YMR303C  Leucine 0.05       4.15\n137448   ICL1         YER065C  Leucine 0.05       3.54\n137451   SFC1         YJR095W  Leucine 0.05       3.72\n137569   MLS1         YNL117W  Leucine 0.05       3.76\n                                              bp\n133768                       multidrug transport\n133772                      leucine biosynthesis\n133858                      amino acid transport\n135186                                  meiosis*\n135187                biological process unknown\n135288                          hexose transport\n135963                       polyamine transport\n135965                biological process unknown\n136102                       signal transduction\n136109                       response to stress*\n136119                          hexose transport\n136151                   response to dessication\n136152                biological process unknown\n136153                                      &lt;NA&gt;\n136189                       response to stress*\n136231 mitochondrion organization and biogenesis\n136233                                      &lt;NA&gt;\n136486                biological process unknown\n137443                             fermentation*\n137448                          glyoxylate cycle\n137451                       fumarate transport*\n137569                          glyoxylate cycle\n                                           mf\n133768         multidrug efflux pump activity\n133772 3-isopropylmalate dehydratase activity\n133858        amino acid transporter activity\n135186             molecular function unknown\n135187             molecular function unknown\n135288          glucose transporter activity*\n135963          spermine transporter activity\n135965             molecular function unknown\n136102             signal transducer activity\n136109               unfolded protein binding\n136119          glucose transporter activity*\n136151             molecular function unknown\n136152             molecular function unknown\n136153                                   &lt;NA&gt;\n136189               unfolded protein binding\n136231             molecular function unknown\n136233                                   &lt;NA&gt;\n136486                 transaldolase activity\n137443         alcohol dehydrogenase activity\n137448              isocitrate lyase activity\n137451 succinate:fumarate antiporter activity\n137569               malate synthase activity",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#aggregating-data",
    "href": "dataframes_intro.html#aggregating-data",
    "title": "11  Data Frames",
    "section": "11.7 Aggregating data",
    "text": "11.7 Aggregating data\nAggregating data, or summarizing by category, is a common way to look for trends or differences in measurements between categories. Use aggregate to find the mean expression by gene symbol.\n\nhead(aggregate(ydat$expression, by=list( ydat$symbol), mean))\n\n  Group.1           x\n1    AAC1  0.52888889\n2    AAC3 -0.21628571\n3   AAD10  0.43833333\n4   AAD14 -0.07166667\n5   AAD16  0.24194444\n6    AAD4 -0.79166667\n\n# or \nhead(aggregate(expression ~ symbol, mean, data=ydat))\n\n  symbol  expression\n1   AAC1  0.52888889\n2   AAC3 -0.21628571\n3  AAD10  0.43833333\n4  AAD14 -0.07166667\n5  AAD16  0.24194444\n6   AAD4 -0.79166667",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#creating-a-data.frame-from-scratch",
    "href": "dataframes_intro.html#creating-a-data.frame-from-scratch",
    "title": "11  Data Frames",
    "section": "11.8 Creating a data.frame from scratch",
    "text": "11.8 Creating a data.frame from scratch\nSometimes it is useful to combine related data into one object. For example, let’s simulate some data.\n\nsmoker = factor(rep(c(\"smoker\", \"non-smoker\"), each=50))\nsmoker_numeric = as.numeric(smoker)\nx = rnorm(100)\nrisk = x + 2*smoker_numeric\n\nWe have two varibles, risk and smoker that are related. We can make a data.frame out of them:\n\nsmoker_risk = data.frame(smoker = smoker, risk = risk)\nhead(smoker_risk)\n\n  smoker     risk\n1 smoker 3.494214\n2 smoker 3.841851\n3 smoker 3.607017\n4 smoker 4.449390\n5 smoker 3.896246\n6 smoker 5.712052\n\n\nR also has plotting shortcuts that work with data.frames to simplify plotting\n\nplot( risk ~ smoker, data=smoker_risk)",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#saving-a-data.frame",
    "href": "dataframes_intro.html#saving-a-data.frame",
    "title": "11  Data Frames",
    "section": "11.9 Saving a data.frame",
    "text": "11.9 Saving a data.frame\nOnce we have a data.frame of interest, we may want to save it. The most portable way to save a data.frame is to use one of the write functions. In this case, let’s save the data as a .csv file.\n\nwrite.csv(smoker_risk, \"smoker_risk.csv\")",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "factors.html",
    "href": "factors.html",
    "title": "12  Factors",
    "section": "",
    "text": "12.1 Factors\nA factor is a special type of vector, normally used to hold a categorical variable–such as smoker/nonsmoker, state of residency, zipcode–in many statistical functions. Such vectors have class “factor”. Factors are primarily used in Analysis of Variance (ANOVA) or other situations when “categories” are needed. When a factor is used as a predictor variable, the corresponding indicator variables are created (more later).\nNote of caution that factors in R often appear to be character vectors when printed, but you will notice that they do not have double quotes around them. They are stored in R as numbers with a key name, so sometimes you will note that the factor behaves like a numeric vector.\n# create the character vector\ncitizen&lt;-c(\"uk\",\"us\",\"no\",\"au\",\"uk\",\"us\",\"us\",\"no\",\"au\") \n\n# convert to factor\ncitizenf&lt;-factor(citizen)                                \ncitizen             \n\n[1] \"uk\" \"us\" \"no\" \"au\" \"uk\" \"us\" \"us\" \"no\" \"au\"\n\ncitizenf\n\n[1] uk us no au uk us us no au\nLevels: au no uk us\n\n# convert factor back to character vector\nas.character(citizenf)\n\n[1] \"uk\" \"us\" \"no\" \"au\" \"uk\" \"us\" \"us\" \"no\" \"au\"\n\n# convert to numeric vector\nas.numeric(citizenf)\n\n[1] 3 4 2 1 3 4 4 2 1\nR stores many data structures as vectors with “attributes” and “class” (just so you have seen this).\nattributes(citizenf)\n\n$levels\n[1] \"au\" \"no\" \"uk\" \"us\"\n\n$class\n[1] \"factor\"\n\nclass(citizenf)\n\n[1] \"factor\"\n\n# note that after unclassing, we can see the \n# underlying numeric structure again\nunclass(citizenf)\n\n[1] 3 4 2 1 3 4 4 2 1\nattr(,\"levels\")\n[1] \"au\" \"no\" \"uk\" \"us\"\nTabulating factors is a useful way to get a sense of the “sample” set available.\ntable(citizenf)\n\ncitizenf\nau no uk us \n 2  2  2  3\nThe default factor levels are the unique set of possible values. It is possible to specify a subset of factor levels. Note how missing values are introduced if a value is not included.\ncitizenf2 &lt;- factor(citizen, levels=c(\"us\", \"uk\"))\ncitizenf2\n\n[1] uk   us   &lt;NA&gt; &lt;NA&gt; uk   us   us   &lt;NA&gt; &lt;NA&gt;\nLevels: us uk\n\ntable(citizenf2)\n\ncitizenf2\nus uk \n 3  2\nMissing values are exlcuded by default. There is an option to override this setting.\naddNA(citizenf2)\n\n[1] uk   us   &lt;NA&gt; &lt;NA&gt; uk   us   us   &lt;NA&gt; &lt;NA&gt;\nLevels: us uk &lt;NA&gt;\n\ntable(addNA(citizenf2))\n\n\n  us   uk &lt;NA&gt; \n   3    2    4",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Factors</span>"
    ]
  },
  {
    "objectID": "factors.html#factors",
    "href": "factors.html#factors",
    "title": "12  Factors",
    "section": "",
    "text": "Caution\n\n\n\nThis emphasizes that default settings may or may not be appropriate for your analysis. It’s important to know what those settings are and choose alternatives as necessary.",
    "crumbs": [
      "Home",
      "R Data Structures",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Factors</span>"
    ]
  },
  {
    "objectID": "appendix.html",
    "href": "appendix.html",
    "title": "Appendix A — Interactive Intro to R",
    "section": "",
    "text": "A.1 Swirl\nThe following is from the swirl website.\nTo get started, we need to install a new package into R.\ninstall.packages('swirl')\nOnce installed, we want to load it into the R workspace so we can use it.\nlibrary('swirl')\nFinally, to get going, start swirl and follow the instructions.\nswirl()",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Interactive Intro to R</span>"
    ]
  },
  {
    "objectID": "appendix.html#swirl",
    "href": "appendix.html#swirl",
    "title": "Appendix A — Interactive Intro to R",
    "section": "",
    "text": "The swirl R package makes it fun and easy to learn R programming and data science. If you are new to R, have no fear.",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Interactive Intro to R</span>"
    ]
  },
  {
    "objectID": "git_and_github.html",
    "href": "git_and_github.html",
    "title": "Appendix B — Git and GitHub",
    "section": "",
    "text": "B.1 install Git and GitHub CLI\nGit is a version control system that allows you to track changes in your code and collaborate with others. GitHub is a web-based platform that hosts Git repositories, making it easy to share and collaborate on projects. Github is NOT the only place to host Git repositories, but it is the most popular and has a large community of users.\nYou can use git by itself locally for version control. However, if you want to collaborate with others, you will need to use a remote repository, such as GitHub. This allows you to share your code with others, track changes, and collaborate on projects.\nTo use Git and GitHub, you need to have Git installed on your computer. You can download it from git-scm.com. After installation, you can check if Git is installed correctly by running the following command in your terminal:\nWe also need the gh command line tool to interact with GitHub. You can install it from cli.github.com. To install, go to the releases page and download the appropriate version for your operating system. For the Mac, it is the file named something like “Macos Universal” and the file will have a .pkg extension. You can install it by double-clicking the file after downloading it.",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git_and_github.html#install-git-and-github-cli",
    "href": "git_and_github.html#install-git-and-github-cli",
    "title": "Appendix B — Git and GitHub",
    "section": "",
    "text": "git --version\n\n\n\n\n\n\n\nUsing the RStudio Terminal\n\n\n\nIf you are using RStudio, you can use the built-in terminal to run Git commands. To open the terminal, go to the “Terminal” tab in the bottom pane of RStudio. This allows you to run Git commands directly from RStudio without needing to switch to a separate terminal application.\n\nFor more details, see the RStudio terminal documentation.",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git_and_github.html#configure-git",
    "href": "git_and_github.html#configure-git",
    "title": "Appendix B — Git and GitHub",
    "section": "B.2 Configure Git",
    "text": "B.2 Configure Git\nAfter installing Git, you need to configure it with your name and email address. This information will be used to identify you as the author of the commits you make. Run the following commands in your terminal, replacing “Your Name” and “you@example.com” with your actual name and email address:\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"you@example.com\"",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git_and_github.html#create-a-github-account",
    "href": "git_and_github.html#create-a-github-account",
    "title": "Appendix B — Git and GitHub",
    "section": "B.3 Create a GitHub account",
    "text": "B.3 Create a GitHub account\nIf you don’t already have a GitHub account, you can create one for free at github.com.",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git_and_github.html#login-to-github-cli",
    "href": "git_and_github.html#login-to-github-cli",
    "title": "Appendix B — Git and GitHub",
    "section": "B.4 Login to GitHub CLI",
    "text": "B.4 Login to GitHub CLI\nAfter installing the GitHub CLI, you need to log in to your GitHub account. Run the following command in your terminal:\ngh auth login",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git_and_github.html#introduction-to-version-control-with-git",
    "href": "git_and_github.html#introduction-to-version-control-with-git",
    "title": "Appendix B — Git and GitHub",
    "section": "B.5 Introduction to Version Control with Git",
    "text": "B.5 Introduction to Version Control with Git\nWelcome to the world of version control! Think of Git as a “save” button for your entire project, but with the ability to go back to previous saves, see exactly what you changed, and even work on different versions of your project at the same time. It’s an essential tool for reproducible and collaborative research.\nIn this tutorial, we’ll learn the absolute basics of Git using the command line directly within RStudio.\n\nB.5.1 Key Git Commands We’ll Learn Today:\n\ngit init: Initializes a new Git repository in your project folder. This is the first step to start tracking your files.\ngit add: Tells Git which files you want to track changes for. You can think of this as putting your changes into a “staging area.”\ngit commit: Takes a snapshot of your staged changes. This is like creating a permanent save point with a descriptive message.\ngit restore: Discards changes in your working directory. It’s a way to undo modifications you haven’t committed yet.\ngit branch: Allows you to create separate timelines of your project. This is useful for developing new features without affecting your main work.\ngit merge: Combines the changes from one branch into another.",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git_and_github.html#the-toy-example-an-r-script",
    "href": "git_and_github.html#the-toy-example-an-r-script",
    "title": "Appendix B — Git and GitHub",
    "section": "B.6 The Toy Example: An R Script",
    "text": "B.6 The Toy Example: An R Script\nFirst, let’s create a simple R script that we can use for our Git exercise. In RStudio, create a new R Script and save it as data_analysis.R.\n# data_analysis.R\n\n# Load necessary libraries\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Create some sample data\ndata &lt;- data.frame(\n  x = 1:10,\n  y = (1:10) ^ 2\n)\n\n# Initial data summary\nsummary(data)",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "git_and_github.html#lets-get-started-with-git",
    "href": "git_and_github.html#lets-get-started-with-git",
    "title": "Appendix B — Git and GitHub",
    "section": "B.7 Let’s Get Started with Git!",
    "text": "B.7 Let’s Get Started with Git!\nOpen the Terminal in RStudio (you can usually find it as a tab next to the Console). We’ll be typing all our Git commands here.\n\n\n\n\n\n\nFigure B.1: This is an overview of how git works along with the commands that make it tick. See this video\n\n\n\n\nB.7.1 Step 1: Initialize Your Git Repository\nFirst, we need to tell Git to start tracking our project folder.\ngit init\nYou’ll see a message like Initialized empty Git repository in.... You might also notice a new .git folder in your project directory (it might be hidden). This is where Git stores all its tracking information. Your default branch is automatically named main.\n\n\nB.7.2 Step 2: Your First Commit\nNow, let’s add our data_analysis.R script to Git’s tracking and make our first “commit.”\n\nAdd the file to the staging area:\ngit add data_analysis.R\nCommit the staged file with a message:\ngit commit -m \"Initial commit: Add basic data script\"\nThe -m flag lets you write your commit message directly in the command. Good commit messages are short but descriptive!\n\n\n\nB.7.3 Step 3: Making and Undoing a Change\nLet’s modify our R script. Add a plotting section to the end of data_analysis.R.\n# ... (keep the previous code)\n\n# Create a plot\nggplot(data, aes(x = x, y = y)) +\n  geom_point() +\n  ggtitle(\"A Simple Scatter Plot\")\nNow, what if we decided we didn’t want this change after all? We can use git restore to go back to our last committed version.\ngit restore data_analysis.R\nIf you look at your data_analysis.R file now, the plotting code will be gone!\n\n\nB.7.4 Step 4: Branching Out\nBranches are a powerful feature. Let’s create a new branch to add our plot without messing up our main branch.\n\nCreate a new branch and switch to it:\ngit checkout -b add-plot\nThis is a shortcut for git branch add-plot and git checkout add-plot.\n\nNow, re-add the plotting code to data_analysis.R.\n# ... (keep the previous code)\n\n# Create a plot\nggplot(data, aes(x = x, y = y)) +\n  geom_point() +\n  ggtitle(\"A Simple Scatter Plot\")\nLet’s commit this change on our new add-plot branch.\ngit add data_analysis.R\ngit commit -m \"feat: Add scatter plot\"\n\n\nB.7.5 Step 5: Seeing Branches in Action\nNow for the magic of branches. Let’s switch back to our main branch.\ngit checkout main\nNow, open your data_analysis.R script in the RStudio editor. The plotting code is gone! That’s because the change only exists on the add-plot branch. The main branch is exactly as we last left it.\nLet’s switch back to our feature branch.\ngit checkout add-plot\nCheck the data_analysis.R script again. The plotting code is back! This demonstrates how branches allow you to work on different versions of your project in isolation.\n\n\nB.7.6 Step 6: Merging Your Work\nOur plot is complete and we’re happy with it. It’s time to merge it back into our main branch to incorporate the new feature.\n\nSwitch back to the main branch, which is our target for the merge:\ngit checkout main\nMerge the add-plot branch into main:\ngit merge add-plot\n\nYou’ll see a message indicating that the merge happened. Now, your main branch has the updated data_analysis.R script with the plotting code!",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "additional_resources.html",
    "href": "additional_resources.html",
    "title": "Appendix C — Additional resources",
    "section": "",
    "text": "C.1 AI",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Additional resources</span>"
    ]
  },
  {
    "objectID": "additional_resources.html#ai",
    "href": "additional_resources.html#ai",
    "title": "Appendix C — Additional resources",
    "section": "",
    "text": "chatGPT\nGemini\nClaude\nDeepSeek\nPerplexity",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Additional resources</span>"
    ]
  },
  {
    "objectID": "dataviz.html",
    "href": "dataviz.html",
    "title": "Appendix D — Data Visualization with ggplot2",
    "section": "",
    "text": "Start with this worked example to get a feel for the ggplot2 package.\n\nhttps://rkabacoff.github.io/datavis/IntroGGPLOT.html\n\nThen, for more detail, I refer you to this excellent ggplot2 tutorial.\nFinally, for more R graphics inspiration, see the R Graph Gallery.",
    "crumbs": [
      "Home",
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Data Visualization with ggplot2</span>"
    ]
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "RPC 519 R and Bioconductor",
    "section": "",
    "text": "Original License:\nTo the extent possible under law,  Sean Davis has waived all copyright and related or neighboring rights to Statistical analysis of functional genomics dataa. This work is published from:  United States.\n\nStatement:\n\nThis modified version of his work adheres to the same Licensing agreement"
  }
]