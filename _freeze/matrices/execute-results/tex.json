{
  "hash": "7da898c752a11ab9e1c7e468f3efe4c4",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor: \"Sean Davis\"\n---\n\n# Matrices\n\nA _matrix_ is a rectangular collection of the same data type (see @fig-datastructures_schematic). It can be viewed\nas a collection of column vectors all of the same length and the same type\n(i.e. numeric, character or logical) OR a collection of row vectors, again all\nof the same type and length. A _data.frame_ is *also* a rectangular array. All\nof the columns must be the same length, but they **may be** of *different* types.\nThe rows and columns of a matrix or data frame can be given names. However\nthese are implemented differently in R; many operations will work for one but\nnot both, often a source of confusion.\n\n![A matrix is a collection of column vectors.](images/datastructures_schematic.png){#fig-datastructures_schematic}\n\n\n## Creating a matrix\n\nThere are many ways to create a matrix in R. One of the simplest is to use the\n`matrix()` function. In the code below, we'll create a matrix from a vector\nfrom 1:16.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:16,nrow=4)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n```\n\n\n:::\n:::\n\n\nThe same is possible, but specifying that the matrix be \"filled\" by row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:16,nrow=4,byrow = TRUE)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n```\n\n\n:::\n:::\n\n\nNotice the subtle difference in the order that the numbers go into the matrix.\n\n\nWe can also build a matrix from parts by \"binding\" vectors together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10 \ny <- rnorm(10)\n```\n:::\n\n\nEach of the vectors above is of length 10 and both are \"numeric\", so we can make\nthem into a matrix. Using `rbind` binds rows (**r**) into a matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- rbind(x,y)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1]       [,2]      [,3]       [,4]      [,5]       [,6]     [,7]\nx  1.00000  2.0000000 3.0000000  4.0000000  5.000000  6.0000000 7.000000\ny -1.30655 -0.2849439 0.5445569 -0.5404574 -1.269572 -0.2017896 1.681029\n      [,8]       [,9]     [,10]\nx 8.000000  9.0000000 10.000000\ny 1.462597 -0.6817514 -1.632114\n```\n\n\n:::\n:::\n\n\nThe alternative to `rbind` is `cbind` that binds columns (**c**) together. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- cbind(x,y)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       x          y\n [1,]  1 -1.3065504\n [2,]  2 -0.2849439\n [3,]  3  0.5445569\n [4,]  4 -0.5404574\n [5,]  5 -1.2695718\n [6,]  6 -0.2017896\n [7,]  7  1.6810294\n [8,]  8  1.4625973\n [9,]  9 -0.6817514\n[10,] 10 -1.6321137\n```\n\n\n:::\n:::\n\n\nInspecting the names associated with rows and columns is often useful,\nparticularly if the names have human meaning. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x\" \"y\"\n```\n\n\n:::\n:::\n\n\nWe can also change the names of the matrix by assigning _valid_ names to the \ncolumns or rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(mat) = c('apples','oranges')\ncolnames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apples\"  \"oranges\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      apples    oranges\n [1,]      1 -1.3065504\n [2,]      2 -0.2849439\n [3,]      3  0.5445569\n [4,]      4 -0.5404574\n [5,]      5 -1.2695718\n [6,]      6 -0.2017896\n [7,]      7  1.6810294\n [8,]      8  1.4625973\n [9,]      9 -0.6817514\n[10,]     10 -1.6321137\n```\n\n\n:::\n:::\n\n\n\n\nMatrices have dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  2\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n## Accessing elements of a matrix\n\nIndexing for matrices works as for vectors except that we now need to\ninclude both the row and column (in that order). We can access elements \nof a matrix using the square bracket [ indexing method. Elements can be \naccessed as `var[r, c]`. Here, `r` and `c` are vectors describing the elements\nof the matrix to select.\n\n::: {.callout-important}\nThe indices in R start with one, meaning that the first element of a vector or the first row/column of a matrix is indexed as one.\n\nThis is different from some other programming languages, such as Python, which use zero-based indexing, meaning that the first element of a vector or the first row/column of a matrix is indexed as zero.\n\nIt is important to be aware of this difference when working with data in R, especially if you are coming from a programming background that uses zero-based indexing. Using the wrong index can lead to unexpected results or errors in your code.\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The 2nd element of the 1st row of mat\nmat[1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n oranges \n-1.30655 \n```\n\n\n:::\n\n```{.r .cell-code}\n# The first ROW of mat\nmat[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  apples  oranges \n 1.00000 -1.30655 \n```\n\n\n:::\n\n```{.r .cell-code}\n# The first COLUMN of mat\nmat[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# and all elements of mat that are > 4; note no comma\nmat[mat>4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n## [1]  5  6  7  8  9 10\n```\n:::\n\n\n::: {.callout-caution}\nNote that in the last case, there is no \",\", so R treats the matrix as a long \nvector (length=20). This is convenient, sometimes, but it can also be a source \nof error, as some code may \"work\" but be doing something unexpected.\n\n:::\n\n\n\nWe can also use indexing to exclude a row or column by prefixing the selection\nwith a `-` sign.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[,-1]       # remove first column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -1.3065504 -0.2849439  0.5445569 -0.5404574 -1.2695718 -0.2017896\n [7]  1.6810294  1.4625973 -0.6817514 -1.6321137\n```\n\n\n:::\n\n```{.r .cell-code}\nmat[-c(1:5),]  # remove first five rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     apples    oranges\n[1,]      6 -0.2017896\n[2,]      7  1.6810294\n[3,]      8  1.4625973\n[4,]      9 -0.6817514\n[5,]     10 -1.6321137\n```\n\n\n:::\n:::\n\n\n## Changing values in a matrix\n\nWe can create a matrix filled with random values drawn from a normal\ndistribution for our work below. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm = matrix(rnorm(20),nrow=10)\nsummary(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1                V2         \n Min.   :-1.7287   Min.   :-2.1252  \n 1st Qu.:-1.0217   1st Qu.:-0.2659  \n Median :-0.7183   Median : 0.4366  \n Mean   :-0.3965   Mean   : 0.3845  \n 3rd Qu.: 0.4372   3rd Qu.: 1.2448  \n Max.   : 1.2721   Max.   : 2.7633  \n```\n\n\n:::\n:::\n\n\nMultiplication and division works similarly to vectors. When multiplying by a \nvector, for example, the values of the vector are reused. In the simplest case, \nlet's multiply the matrix by a constant (vector of length 1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# multiply all values in the matrix by 20\nm2 = m*20\nsummary(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1                V2         \n Min.   :-34.573   Min.   :-42.504  \n 1st Qu.:-20.433   1st Qu.: -5.319  \n Median :-14.367   Median :  8.731  \n Mean   : -7.930   Mean   :  7.691  \n 3rd Qu.:  8.744   3rd Qu.: 24.895  \n Max.   : 25.443   Max.   : 55.265  \n```\n\n\n:::\n:::\n\n\nBy combining subsetting with assignment, we can make changes to just part of a \nmatrix. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# and add 100 to the first column of m\nm2[,1] = m2[,1] + 100\n# summarize m\nsummary(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1               V2         \n Min.   : 65.43   Min.   :-42.504  \n 1st Qu.: 79.57   1st Qu.: -5.319  \n Median : 85.63   Median :  8.731  \n Mean   : 92.07   Mean   :  7.691  \n 3rd Qu.:108.74   3rd Qu.: 24.895  \n Max.   :125.44   Max.   : 55.265  \n```\n\n\n:::\n:::\n\n\nA somewhat common transformation for a matrix is to transpose which changes\nrows to columns. One might need to do this if an assay output from a lab \nmachine puts samples in rows and genes in columns, for example, while in \nBioconductor/R, we often want the samples in columns and the genes in rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]     [,2]      [,3]     [,4]       [,5]     [,6]       [,7]\n[1,]  82.60753 84.09010  65.42690 87.17645 114.365134 74.39922 116.755042\n[2,] -19.99175 55.26513 -42.50417 30.37719  -0.662172 15.96026   2.494758\n           [,8]     [,9]    [,10]\n[1,] 125.442777 78.55289 91.87916\n[2,]  -6.871007 14.96736 27.87335\n```\n\n\n:::\n:::\n\n\n## Calculations on matrix rows and columns\n\nAgain, we just need a matrix to play with. We'll use `rnorm` again, but with a\nslight twist. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm3 = matrix(rnorm(100,5,2),ncol=10) # what does the 5 mean here? And the 2?\n```\n:::\n\n\nSince these data are from a normal distribution, we can look at a row (or column)\nto see what the mean and standard deviation are.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(m3[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.25246\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(m3[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.351132\n```\n\n\n:::\n\n```{.r .cell-code}\n# or a row\nmean(m3[1,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.073799\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(m3[1,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.762386\n```\n\n\n:::\n:::\n\n\nThere are some useful convenience functions for computing means and sums \nof data in **all** of the columns and rows of matrices. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 5.252460 5.253362 5.743336 4.150106 3.995761 2.906782 4.905868 4.617782\n [9] 3.670924 5.157113\n```\n\n\n:::\n\n```{.r .cell-code}\nrowMeans(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 4.073799 4.559017 4.321635 4.559505 4.033766 4.850547 4.292942 5.116671\n [9] 5.428672 4.416941\n```\n\n\n:::\n\n```{.r .cell-code}\nrowSums(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 40.73799 45.59017 43.21635 45.59505 40.33766 48.50547 42.92942 51.16671\n [9] 54.28672 44.16941\n```\n\n\n:::\n\n```{.r .cell-code}\ncolSums(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 52.52460 52.53362 57.43336 41.50106 39.95761 29.06782 49.05868 46.17782\n [9] 36.70924 51.57113\n```\n\n\n:::\n:::\n\n\nWe can look at the distribution of column means:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save as a variable\ncmeans = colMeans(m3)\nsummary(cmeans)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  2.907   4.034   4.762   4.565   5.229   5.743 \n```\n\n\n:::\n:::\n\nNote that this is centered pretty closely around the selected mean of `5` above.\n\nHow about the standard deviation? There is not a `colSd` function, but it turns\nout that we can easily apply functions that take vectors as input, like `sd` and\n\"apply\" them across either the rows (the first dimension) or columns (the second)\ndimension.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsds = apply(m3, 2, sd)\nsummary(csds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.421   1.721   1.977   1.995   2.291   2.612 \n```\n\n\n:::\n:::\n\n\nAgain, take a look at the distribution which is centered quite close to the \nselected standard deviation when we created our matrix.\n\n\n## Exercises\n\n\n\n\n### Data preparation\n\nFor this set of exercises, we are going to rely on a dataset that comes with R.\nIt gives the number of sunspots per month from 1749-1983. The dataset comes as \na `ts` or time series data type which I convert to a matrix using the following\ncode. \n\nJust run the code as is and focus on the rest of the exercises. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(sunspots)\nsunspot_mat <- matrix(as.vector(sunspots),ncol=12,byrow = TRUE)\ncolnames(sunspot_mat) <- as.character(1:12)\nrownames(sunspot_mat) <- as.character(1749:1983)\n```\n:::\n\n\n### Questions\n\n-   After the conversion above, what does `sunspot_mat` look like? Use functions\nto find the number of rows, the number of columns, the class, and some basic\nsummary statistics.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    ncol(sunspot_mat)\n    nrow(sunspot_mat)\n    dim(sunspot_mat)\n    summary(sunspot_mat)\n    head(sunspot_mat)\n    tail(sunspot_mat)\n    ```\n    :::\n\n\n\n-   Practice subsetting the matrix a bit by selecting:\n    - The first 10 years (rows)\n    - The month of July (7th column)\n    - The value for July, 1979 using the rowname to do the selection.\n  \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    sunspot_mat[1:10,]\n    sunspot_mat[,7]\n    sunspot_mat['1979',7]\n    ```\n    :::\n\n\n\n1.  These next few exercises take advantage of the fact that calling a univariate\nstatistical function (one that expects a vector) works for matrices by just making\na vector of all the values in the matrix. \nWhat is the highest (max) number of sunspots recorded in these data?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    max(sunspot_mat)\n    ```\n    :::\n\n\n1.  And the minimum?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    min(sunspot_mat)\n    ```\n    :::\n\n\n1.  And the overall mean and median?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    mean(sunspot_mat)\n    median(sunspot_mat)\n    ```\n    :::\n\n\n1.  Use the `hist()` function to look at the distribution of all the monthly \nsunspot data. \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    hist(sunspot_mat)\n    ```\n    :::\n\n1.  Read about the `breaks` argument to `hist()` to try to increase the number of\nbreaks in the histogram to increase the resolution slightly. Adjust your `hist()`\nand breaks to your liking.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    hist(sunspot_mat, breaks=40)\n    ```\n    :::\n\n\n\n1.  Now, let's move on to summarizing the data a bit to learn about the pattern of \nsunspots varies by month or by year. Examine the dataset again. What do the\ncolumns represent? And the rows?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    # just a quick glimpse of the data will give us a sense\n    head(sunspot_mat)\n    ```\n    :::\n\n\n1.  We'd like to look at the distribution of sunspots by month. How can we do that?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    # the mean of the columns is the mean number of sunspots per month.\n    colMeans(sunspot_mat)\n    \n    # Another way to write the same thing:\n    apply(sunspot_mat, 2, mean)\n    ```\n    :::\n\n1.  Assign the month summary above to a variable and summarize it to get a sense\nof the spread over months.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    monthmeans = colMeans(sunspot_mat)\n    summary(monthmeans)\n    ```\n    :::\n\n\n1.  Play the same game for years to get the per-year mean?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    ymeans = rowMeans(sunspot_mat)\n    summary(ymeans)\n    ```\n    :::\n\n\n1.  Make a plot of the yearly means. Do you see a pattern?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    plot(ymeans)\n    # or make it clearer\n    plot(ymeans, type='l')\n    ```\n    :::\n\n\n\n\n\n\n\n",
    "supporting": [
      "matrices_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}