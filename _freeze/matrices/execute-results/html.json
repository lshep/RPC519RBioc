{
  "hash": "7da898c752a11ab9e1c7e468f3efe4c4",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor: \"Sean Davis\"\n---\n\n# Matrices\n\nA _matrix_ is a rectangular collection of the same data type (see @fig-datastructures_schematic). It can be viewed\nas a collection of column vectors all of the same length and the same type\n(i.e. numeric, character or logical) OR a collection of row vectors, again all\nof the same type and length. A _data.frame_ is *also* a rectangular array. All\nof the columns must be the same length, but they **may be** of *different* types.\nThe rows and columns of a matrix or data frame can be given names. However\nthese are implemented differently in R; many operations will work for one but\nnot both, often a source of confusion.\n\n![A matrix is a collection of column vectors.](images/datastructures_schematic.png){#fig-datastructures_schematic}\n\n\n## Creating a matrix\n\nThere are many ways to create a matrix in R. One of the simplest is to use the\n`matrix()` function. In the code below, we'll create a matrix from a vector\nfrom 1:16.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:16,nrow=4)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n```\n\n\n:::\n:::\n\n\nThe same is possible, but specifying that the matrix be \"filled\" by row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:16,nrow=4,byrow = TRUE)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n```\n\n\n:::\n:::\n\n\nNotice the subtle difference in the order that the numbers go into the matrix.\n\n\nWe can also build a matrix from parts by \"binding\" vectors together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10 \ny <- rnorm(10)\n```\n:::\n\n\nEach of the vectors above is of length 10 and both are \"numeric\", so we can make\nthem into a matrix. Using `rbind` binds rows (**r**) into a matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- rbind(x,y)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       [,1]     [,2]       [,3]      [,4]     [,5]     [,6]        [,7]\nx  1.000000 2.000000  3.0000000 4.0000000 5.000000 6.000000 7.000000000\ny -1.325599 2.625988 -0.5995257 0.2640878 1.066886 1.026504 0.007406872\n       [,8]     [,9]     [,10]\nx 8.0000000 9.000000 10.000000\ny 0.9496984 1.374093  1.862218\n```\n\n\n:::\n:::\n\n\nThe alternative to `rbind` is `cbind` that binds columns (**c**) together. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- cbind(x,y)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       x            y\n [1,]  1 -1.325598661\n [2,]  2  2.625987528\n [3,]  3 -0.599525738\n [4,]  4  0.264087823\n [5,]  5  1.066885781\n [6,]  6  1.026504421\n [7,]  7  0.007406872\n [8,]  8  0.949698364\n [9,]  9  1.374092714\n[10,] 10  1.862218163\n```\n\n\n:::\n:::\n\n\nInspecting the names associated with rows and columns is often useful,\nparticularly if the names have human meaning. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x\" \"y\"\n```\n\n\n:::\n:::\n\n\nWe can also change the names of the matrix by assigning _valid_ names to the \ncolumns or rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(mat) = c('apples','oranges')\ncolnames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apples\"  \"oranges\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      apples      oranges\n [1,]      1 -1.325598661\n [2,]      2  2.625987528\n [3,]      3 -0.599525738\n [4,]      4  0.264087823\n [5,]      5  1.066885781\n [6,]      6  1.026504421\n [7,]      7  0.007406872\n [8,]      8  0.949698364\n [9,]      9  1.374092714\n[10,]     10  1.862218163\n```\n\n\n:::\n:::\n\n\n\n\nMatrices have dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  2\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n## Accessing elements of a matrix\n\nIndexing for matrices works as for vectors except that we now need to\ninclude both the row and column (in that order). We can access elements \nof a matrix using the square bracket [ indexing method. Elements can be \naccessed as `var[r, c]`. Here, `r` and `c` are vectors describing the elements\nof the matrix to select.\n\n::: {.callout-important}\nThe indices in R start with one, meaning that the first element of a vector or the first row/column of a matrix is indexed as one.\n\nThis is different from some other programming languages, such as Python, which use zero-based indexing, meaning that the first element of a vector or the first row/column of a matrix is indexed as zero.\n\nIt is important to be aware of this difference when working with data in R, especially if you are coming from a programming background that uses zero-based indexing. Using the wrong index can lead to unexpected results or errors in your code.\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The 2nd element of the 1st row of mat\nmat[1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  oranges \n-1.325599 \n```\n\n\n:::\n\n```{.r .cell-code}\n# The first ROW of mat\nmat[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   apples   oranges \n 1.000000 -1.325599 \n```\n\n\n:::\n\n```{.r .cell-code}\n# The first COLUMN of mat\nmat[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# and all elements of mat that are > 4; note no comma\nmat[mat>4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n## [1]  5  6  7  8  9 10\n```\n:::\n\n\n::: {.callout-caution}\nNote that in the last case, there is no \",\", so R treats the matrix as a long \nvector (length=20). This is convenient, sometimes, but it can also be a source \nof error, as some code may \"work\" but be doing something unexpected.\n\n:::\n\n\n\nWe can also use indexing to exclude a row or column by prefixing the selection\nwith a `-` sign.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[,-1]       # remove first column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -1.325598661  2.625987528 -0.599525738  0.264087823  1.066885781\n [6]  1.026504421  0.007406872  0.949698364  1.374092714  1.862218163\n```\n\n\n:::\n\n```{.r .cell-code}\nmat[-c(1:5),]  # remove first five rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     apples     oranges\n[1,]      6 1.026504421\n[2,]      7 0.007406872\n[3,]      8 0.949698364\n[4,]      9 1.374092714\n[5,]     10 1.862218163\n```\n\n\n:::\n:::\n\n\n## Changing values in a matrix\n\nWe can create a matrix filled with random values drawn from a normal\ndistribution for our work below. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm = matrix(rnorm(20),nrow=10)\nsummary(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1                V2         \n Min.   :-1.4939   Min.   :-1.2081  \n 1st Qu.:-0.9215   1st Qu.:-0.6468  \n Median :-0.1318   Median : 0.1367  \n Mean   :-0.0953   Mean   : 0.1488  \n 3rd Qu.: 0.3056   3rd Qu.: 0.5619  \n Max.   : 2.0916   Max.   : 2.4685  \n```\n\n\n:::\n:::\n\n\nMultiplication and division works similarly to vectors. When multiplying by a \nvector, for example, the values of the vector are reused. In the simplest case, \nlet's multiply the matrix by a constant (vector of length 1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# multiply all values in the matrix by 20\nm2 = m*20\nsummary(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1                V2         \n Min.   :-29.879   Min.   :-24.161  \n 1st Qu.:-18.430   1st Qu.:-12.936  \n Median : -2.637   Median :  2.733  \n Mean   : -1.906   Mean   :  2.976  \n 3rd Qu.:  6.112   3rd Qu.: 11.239  \n Max.   : 41.833   Max.   : 49.370  \n```\n\n\n:::\n:::\n\n\nBy combining subsetting with assignment, we can make changes to just part of a \nmatrix. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# and add 100 to the first column of m\nm2[,1] = m2[,1] + 100\n# summarize m\nsummary(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1               V2         \n Min.   : 70.12   Min.   :-24.161  \n 1st Qu.: 81.57   1st Qu.:-12.936  \n Median : 97.36   Median :  2.733  \n Mean   : 98.09   Mean   :  2.976  \n 3rd Qu.:106.11   3rd Qu.: 11.239  \n Max.   :141.83   Max.   : 49.370  \n```\n\n\n:::\n:::\n\n\nA somewhat common transformation for a matrix is to transpose which changes\nrows to columns. One might need to do this if an assay output from a lab \nmachine puts samples in rows and genes in columns, for example, while in \nBioconductor/R, we often want the samples in columns and the genes in rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         [,1]      [,2]      [,3]       [,4]      [,5]       [,6]      [,7]\n[1,] 97.54502 70.121171 118.95653 141.832989 89.824526 105.547895  78.81841\n[2,] 13.11580  2.993531  49.36978   2.472511  5.607523  -6.200718 -15.18058\n          [,8]      [,9]     [,10]\n[1,] 106.30054  97.18116  74.81129\n[2,]  21.36702 -19.62368 -24.16138\n```\n\n\n:::\n:::\n\n\n## Calculations on matrix rows and columns\n\nAgain, we just need a matrix to play with. We'll use `rnorm` again, but with a\nslight twist. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm3 = matrix(rnorm(100,5,2),ncol=10) # what does the 5 mean here? And the 2?\n```\n:::\n\n\nSince these data are from a normal distribution, we can look at a row (or column)\nto see what the mean and standard deviation are.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(m3[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.549797\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(m3[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.541549\n```\n\n\n:::\n\n```{.r .cell-code}\n# or a row\nmean(m3[1,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.608359\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(m3[1,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.647011\n```\n\n\n:::\n:::\n\n\nThere are some useful convenience functions for computing means and sums \nof data in **all** of the columns and rows of matrices. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 5.549797 4.505066 5.083448 4.682110 5.265026 5.246739 3.614876 5.350698\n [9] 5.049795 5.036546\n```\n\n\n:::\n\n```{.r .cell-code}\nrowMeans(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 3.608359 5.881085 5.650431 5.844686 4.932823 5.843897 4.052513 3.870038\n [9] 5.298616 4.401653\n```\n\n\n:::\n\n```{.r .cell-code}\nrowSums(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 36.08359 58.81085 56.50431 58.44686 49.32823 58.43897 40.52513 38.70038\n [9] 52.98616 44.01653\n```\n\n\n:::\n\n```{.r .cell-code}\ncolSums(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 55.49797 45.05066 50.83448 46.82110 52.65026 52.46739 36.14876 53.50698\n [9] 50.49795 50.36546\n```\n\n\n:::\n:::\n\n\nWe can look at the distribution of column means:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save as a variable\ncmeans = colMeans(m3)\nsummary(cmeans)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  3.615   4.771   5.067   4.938   5.260   5.550 \n```\n\n\n:::\n:::\n\nNote that this is centered pretty closely around the selected mean of `5` above.\n\nHow about the standard deviation? There is not a `colSd` function, but it turns\nout that we can easily apply functions that take vectors as input, like `sd` and\n\"apply\" them across either the rows (the first dimension) or columns (the second)\ndimension.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsds = apply(m3, 2, sd)\nsummary(csds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.542   1.798   1.915   2.047   2.214   2.699 \n```\n\n\n:::\n:::\n\n\nAgain, take a look at the distribution which is centered quite close to the \nselected standard deviation when we created our matrix.\n\n\n## Exercises\n\n\n\n\n### Data preparation\n\nFor this set of exercises, we are going to rely on a dataset that comes with R.\nIt gives the number of sunspots per month from 1749-1983. The dataset comes as \na `ts` or time series data type which I convert to a matrix using the following\ncode. \n\nJust run the code as is and focus on the rest of the exercises. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(sunspots)\nsunspot_mat <- matrix(as.vector(sunspots),ncol=12,byrow = TRUE)\ncolnames(sunspot_mat) <- as.character(1:12)\nrownames(sunspot_mat) <- as.character(1749:1983)\n```\n:::\n\n\n### Questions\n\n-   After the conversion above, what does `sunspot_mat` look like? Use functions\nto find the number of rows, the number of columns, the class, and some basic\nsummary statistics.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    ncol(sunspot_mat)\n    nrow(sunspot_mat)\n    dim(sunspot_mat)\n    summary(sunspot_mat)\n    head(sunspot_mat)\n    tail(sunspot_mat)\n    ```\n    :::\n\n\n\n-   Practice subsetting the matrix a bit by selecting:\n    - The first 10 years (rows)\n    - The month of July (7th column)\n    - The value for July, 1979 using the rowname to do the selection.\n  \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    sunspot_mat[1:10,]\n    sunspot_mat[,7]\n    sunspot_mat['1979',7]\n    ```\n    :::\n\n\n\n1.  These next few exercises take advantage of the fact that calling a univariate\nstatistical function (one that expects a vector) works for matrices by just making\na vector of all the values in the matrix. \nWhat is the highest (max) number of sunspots recorded in these data?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    max(sunspot_mat)\n    ```\n    :::\n\n\n1.  And the minimum?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    min(sunspot_mat)\n    ```\n    :::\n\n\n1.  And the overall mean and median?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    mean(sunspot_mat)\n    median(sunspot_mat)\n    ```\n    :::\n\n\n1.  Use the `hist()` function to look at the distribution of all the monthly \nsunspot data. \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    hist(sunspot_mat)\n    ```\n    :::\n\n1.  Read about the `breaks` argument to `hist()` to try to increase the number of\nbreaks in the histogram to increase the resolution slightly. Adjust your `hist()`\nand breaks to your liking.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    hist(sunspot_mat, breaks=40)\n    ```\n    :::\n\n\n\n1.  Now, let's move on to summarizing the data a bit to learn about the pattern of \nsunspots varies by month or by year. Examine the dataset again. What do the\ncolumns represent? And the rows?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    # just a quick glimpse of the data will give us a sense\n    head(sunspot_mat)\n    ```\n    :::\n\n\n1.  We'd like to look at the distribution of sunspots by month. How can we do that?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    # the mean of the columns is the mean number of sunspots per month.\n    colMeans(sunspot_mat)\n    \n    # Another way to write the same thing:\n    apply(sunspot_mat, 2, mean)\n    ```\n    :::\n\n1.  Assign the month summary above to a variable and summarize it to get a sense\nof the spread over months.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    monthmeans = colMeans(sunspot_mat)\n    summary(monthmeans)\n    ```\n    :::\n\n\n1.  Play the same game for years to get the per-year mean?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    ymeans = rowMeans(sunspot_mat)\n    summary(ymeans)\n    ```\n    :::\n\n\n1.  Make a plot of the yearly means. Do you see a pattern?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    plot(ymeans)\n    # or make it clearer\n    plot(ymeans, type='l')\n    ```\n    :::\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}