{
  "hash": "05a88513f90e6b53cfba3efd08544a91",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Vectors\"\nauthor: \"Sean Davis\"\n---\n\n## What is a Vector?\n\nA vector is the simplest and most basic data structure in R. It is a\none-dimensional, ordered collection of elements, where all the elements are of\nthe same data type. Vectors can store various types of data, such as numeric,\ncharacter, or logical values. @fig-vector shows a pictorial representation of\nthree vector examples.\n\n![\"Pictorial representation of three vector examples. The first vector is a\nnumeric vector. The second is a 'logical' vector. The third is a character\nvector. Vectors also have indices and, optionally, names. \"](images/vector.png){#fig-vector}\n\nIn this chapter, we will provide a comprehensive overview of vectors, including\nhow to create, access, and manipulate them. We will also discuss some unique\nproperties and rules associated with vectors, and explore their applications in\ndata analysis tasks.\n\n\nIn R, even a single value is a vector with length=1. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nz = 1\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\nIn the code above, we \"assigned\" the value 1 to the variable named `z`. Typing `z` by itself is an \"expression\" that returns a result which is, in this case, the value that we just assigned. The `length` method takes an R object and returns the R length. There are numerous ways of asking R about what an object represents, and `length` is one of them.\n\n\nVectors can contain numbers, strings (character data), or logical values\n(`TRUE` and `FALSE`) or other \"atomic\" data types @tbl-simpletypes. *Vectors cannot contain a mix of types!* We will\nintroduce another data structure, the R `list` for situations when we need to\nstore a mix of base R data types. \n\n\n|  Data type |  Stores  |\n|-----------|------------------------|\n|   numeric | floating point numbers |\n|    integer|           integers     |\n|   complex |      complex numbers   |\n|   factor  |      categorical data  |\n|  character|          strings       |\n|   logical |      TRUE or FALSE     |\n|     NA    |          missing       |\n|     NULL   |           empty  |   \n|   function |       function type    |\n\n: Atomic (simplest) data types in R. {#tbl-simpletypes}\n\n## Creating vectors\n\nCharacter vectors (also sometimes called \"string\" vectors) are entered with each value\nsurrounded by single or double quotes; either is acceptable, but they\nmust match. They are always displayed by R with double quotes. Here are some examples of creating vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# examples of vectors\nc('hello','world')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\" \"world\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(1,3,4,5,1,2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 4 5 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\nc(1.12341e7,78234.126)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11234100.00    78234.13\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE,FALSE,TRUE,TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# note how in the next case the TRUE is converted to \"TRUE\"\n# with quotes around it.\nc(TRUE,'hello')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"TRUE\"  \"hello\"\n```\n\n\n:::\n:::\n\n\nWe can also create vectors as \"regular sequences\" of numbers. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a vector of integers from 1 to 10\nx = 1:10\n# and backwards\nx = 10:1\n```\n:::\n\n\nThe `seq` function can create more flexible regular sequences. \n  \n\n::: {.cell}\n\n```{.r .cell-code}\n# create a vector of numbers from 1 to 4 skipping by 0.3\ny = seq(1,4,0.3)\n```\n:::\n\n\n\nAnd creating a new vector by concatenating existing vectors is possible, as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a sequence by concatenating two other sequences\nz = c(y,x)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1.0  1.3  1.6  1.9  2.2  2.5  2.8  3.1  3.4  3.7  4.0 10.0  9.0  8.0  7.0\n[16]  6.0  5.0  4.0  3.0  2.0  1.0\n```\n\n\n:::\n:::\n\n\n\n## Vector Operations\n\nOperations on a single vector are typically done element-by-element. For example, we can add `2` to a vector, `2` is added to each element of the vector and a new vector of the same length is returned.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1:10\nx + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  3  4  5  6  7  8  9 10 11 12\n```\n\n\n:::\n:::\n\n\nIf the operation involves two vectors, the following rules apply. If the vectors are the same length: R simply applies the operation to each pair of elements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  8 10 12 14 16 18 20\n```\n\n\n:::\n:::\n\n\nIf the vectors are different lengths, but one length a multiple of the other, R\nreuses the shorter vector as needed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1:10\ny = c(1,2)\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  4  3  8  5 12  7 16  9 20\n```\n\n\n:::\n:::\n\n\nIf the vectors are different lengths, but one length *not* a multiple of the\nother, R reuses the shorter vector as needed *and* delivers a\nwarning.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1:10\ny = c(2,3,4)\nx * y\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in x * y: longer object length is not a multiple of shorter object\nlength\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  6 12  8 15 24 14 24 36 20\n```\n\n\n:::\n:::\n\n\n\nTypical operations include multiplication (\"\\*\"), addition,\nsubtraction, division, exponentiation (\"\\^\"), but many operations\nin R operate on vectors and are then called \"vectorized\".\n\n::: {.callout-warning}\nBe aware of the recycling rule when working with vectors of different lengths, as it may lead to unexpected results if you're not careful.\n:::\n\n\n\n## Logical Vectors\n\nLogical vectors are vectors composed on only the values `TRUE` and\n`FALSE`. Note the all-upper-case and no quotation marks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na = c(TRUE,FALSE,TRUE)\n\n# we can also create a logical vector from a numeric vector\n# 0 = false, everything else is 1\nb = c(1,0,217)\nd = as.logical(b)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# test if a and d are the same at every element\nall.equal(a,d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# We can also convert from logical to numeric\nas.numeric(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 0 1\n```\n\n\n:::\n:::\n\n\n### Logical Operators\n\nSome operators like `<, >, ==, >=, <=, !=` can be used to create logical\nvectors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a numeric vector\nx = 1:10\n# testing whether x > 5 creates a logical vector\nx > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nx <= 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nx != 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nx == 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nWe can also assign the results to a variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = (x == 5)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n## Indexing Vectors\n\nIn R, an index is used to refer to a specific element or\nset of elements in an vector (or other data structure). [R uses `[` and `]` to perform indexing,\nalthough other approaches to getting subsets of larger data\nstructures are common in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = seq(0,1,0.1)\n# create a new vector from the 4th element of x\nx[4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3\n```\n\n\n:::\n:::\n\n\nWe can even use other vectors to perform the \"indexing\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(3,5,6)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2 0.4 0.5\n```\n\n\n:::\n\n```{.r .cell-code}\ny = 3:6\nx[y]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2 0.3 0.4 0.5\n```\n\n\n:::\n:::\n\n\n\nCombining the concept of indexing with the concept of logical vectors\nresults in a very power combination.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use help('rnorm') to figure out what is happening next\nmyvec = rnorm(10)\n\n# create logical vector that is TRUE where myvec is >0.25\ngt1 = (myvec > 0.25)\nsum(gt1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# and use our logical vector to create a vector of myvec values that are >0.25\nmyvec[gt1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8374351 2.1755444 0.4164355\n```\n\n\n:::\n\n```{.r .cell-code}\n# or <=0.25 using the logical \"not\" operator, \"!\"\nmyvec[!gt1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.7322452 -0.6779004 -1.3999144  0.1521377 -0.4009818  0.1829415 -0.6192756\n```\n\n\n:::\n\n```{.r .cell-code}\n# shorter, one line approach\nmyvec[myvec > 0.25]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8374351 2.1755444 0.4164355\n```\n\n\n:::\n:::\n\n\n## Named Vectors\n\nNamed vectors are vectors with labels or names assigned to their elements.\nThese names can be used to access and manipulate the elements in a more\nmeaningful way.\n\nTo create a named vector, use the `names()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit_prices <- c(0.5, 0.75, 1.25)\nnames(fruit_prices) <- c(\"apple\", \"banana\", \"cherry\")\nprint(fruit_prices)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n apple banana cherry \n  0.50   0.75   1.25 \n```\n\n\n:::\n:::\n\n\nYou can also access and modify elements using their names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbanana_price <- fruit_prices[\"banana\"]\nprint(banana_price)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbanana \n  0.75 \n```\n\n\n:::\n\n```{.r .cell-code}\nfruit_prices[\"apple\"] <- 0.6\nprint(fruit_prices)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n apple banana cherry \n  0.60   0.75   1.25 \n```\n\n\n:::\n:::\n\n\n\n## Character Vectors, A.K.A. Strings\n\nR uses the `paste` function to concatenate strings.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(\"abc\",\"def\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"abc def\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(\"abc\",\"def\",sep=\"THISSEP\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"abcTHISSEPdef\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste0(\"abc\",\"def\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"abcdef\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## [1] \"abcdef\"\npaste(c(\"X\",\"Y\"),1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"X 1\"  \"Y 2\"  \"X 3\"  \"Y 4\"  \"X 5\"  \"Y 6\"  \"X 7\"  \"Y 8\"  \"X 9\"  \"Y 10\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(c(\"X\",\"Y\"),1:10,sep=\"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"X_1\"  \"Y_2\"  \"X_3\"  \"Y_4\"  \"X_5\"  \"Y_6\"  \"X_7\"  \"Y_8\"  \"X_9\"  \"Y_10\"\n```\n\n\n:::\n:::\n\n\nWe can count the number of characters in a string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnchar('abc')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nnchar(c('abc','d',123456))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 1 6\n```\n\n\n:::\n:::\n\n        \nPulling out parts of strings is also sometimes useful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubstr('This is a good sentence.',start=10,stop=15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \" good \"\n```\n\n\n:::\n:::\n\n\nAnother common operation is to replace something in a string with something (a find-and-replace).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsub('This','That','This is a good sentence.')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"That is a good sentence.\"\n```\n\n\n:::\n:::\n\n\nWhen we want to find all strings that match some other string, we can use `grep`, or \"grab regular expression\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'),value=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"abcdef\" \"abcd\"   \"bcde\"  \n```\n\n\n:::\n:::\n\n\nRead about the `grepl` function (`?grepl`). Use that function to\nreturn a logical vector (TRUE/FALSE) for each entry above with an `a`\nin it.\n\n## Missing Values, AKA “NA”\n\nR has a special value, “NA”, that represents a “missing” value, or *Not Available*, in a\nvector or other data structure. Here, we just create a vector to experiment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1:5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nx[2] = NA\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1 NA  3  4  5\n```\n\n\n:::\n:::\n\nThe length of `x` is unchanged, but there is one value that is marked as \"missing\" by virtue of being `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nWe can remove `NA` values by using indexing. In the following, `is.na(x)` returns a logical vector the\nlength of `x`. The `!` is the logical _NOT_ operator and converts `TRUE` to `FALSE` and vice-versa.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[!is.na(x)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 4 5\n```\n\n\n:::\n:::\n\n\n\n## Exercises\n\n1.  Create a numeric vector called `temperatures` containing the following values: 72, 75, 78, 81, 76, 73.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    temperatures <- c(72, 75, 78, 81, 76, 73, 93)\n    ```\n    :::\n\n\n1.  Create a character vector called `days` containing the following values: \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\".\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    days <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\n    ```\n    :::\n\n\n3.  Calculate the average temperature for the week and store it in a variable called `average_temperature`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    average_temperature <- mean(temperatures)\n    ```\n    :::\n\n\n4.  Create a named vector called `weekly_temperatures`, where the names are the days of the week and the values are the temperatures from the `temperatures` vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    weekly_temperatures <- temperatures\n    names(weekly_temperatures) <- days\n    ```\n    :::\n\n\n5.  Create a numeric vector called `ages` containing the following values: 25, 30, 35, 40, 45, 50, 55, 60.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    ages <- c(25, 30, 35, 40, 45, 50, 55, 60)\n    ```\n    :::\n\n\n6.  Create a logical vector called `is_adult` by checking if the elements in the `ages` vector are greater than or equal to 18.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    is_adult <- ages >= 18\n    ```\n    :::\n\n\n7.  Calculate the sum and product of the `ages` vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    sum_ages <- sum(ages)\n    product_ages <- prod(ages)\n    ```\n    :::\n\n\n8.  Extract the ages greater than or equal to 40 from the `ages` vector and store them in a variable called `older_ages`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    older_ages <- ages[ages >= 40]\n    ```\n    :::\n\n",
    "supporting": [
      "vectors_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}