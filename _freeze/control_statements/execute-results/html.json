{
  "hash": "0d63694decd7ecfb197c7ce448ce6d13",
  "result": {
    "engine": "knitr",
    "markdown": "# Control Statements\n\nControl statements help determine the flow and execution of commands based on\nconditional statements. This chapter will cover a brief overview of the\nfollowing:\n\n- Conditional Statements\n  * if\n  * if-else\n  * ifelse\n\n- Loops\n  * for\n  * while\n  * repeat-break\n  \n- Special\n  * break\n  * return\n  * next\n\n- Other\n  * nested\n  * try / tryCatch\n  * vectorization and apply functions\n\n\n::: {.callout-important}\nPay attention to syntax. It is important to include all parenthesis and\nbrackets. In general if you have an open parenthesis or bracket, you will need a\nclosed parenthesis or bracket.\n:::\n\n::: {.callout-tip}\nGood coding practices involve consistent indenting and spacing. Once a control\nstatement is initialized, all code in its brackets are indented to show clearly\nwhat code/statements are being executed for that section. This becomes\nespecially important if you start nesting control statements.  \n:::\n\n## Conditional Statements\n\n### if \n\nLet's start with an `if` statement. An if statement evaluates an expression and\ndepending on its result performs a sub-section of select code.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (expression){\n  # additional code to run if expression is TRUE\n  ...\n}\n```\n:::\n\nThe expression contained in parenthesis will result in a boolean (TRUE/FALSE)\nvalue used to determine if the code in the braces should be executed. \n\n**Example:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 12\nif (x > 0){\n  message(x, \" is greater than 0\")\n  x <- 0\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n12 is greater than 0\n```\n\n\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\nNotice all lines in the braces are executed including a assignment that changes\nour original value\n:::\n\n### if-else\n\nAn `if-else` statement adds additional code to be executed if the expression is\nFALSE.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (expression){\n  # additional code to run if expression is TRUE\n  ...\n} else {\n  # additional code to run if expression if FALSE\n  ...\n}\n```\n:::\n\nWe could read this allowed as if the expression is true execute this code else\nif the expression is false execute this other code.\n\n**Example:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (x > 0){\n  message(x, \" is greater than 0\")\n  x <- 0\n} else {\n  message(x, \" is not greater than 0\")\n  x <- x + 2\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n0 is not greater than 0\n```\n\n\n:::\n:::\n\n\nWhat is x now?\n\n\n### ifelse\n\nA specialized if-else statement is the `ifelse`. It is a simplified version\nwhere an object can be coerced into logical form and return values for\ntrue/false.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nifelse(test_expression, yes_value, no_value)\n```\n:::\n\n\n**Example**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_vec <- -3:3\nifelse(num_vec >= 0, \"positive\", \"negative\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"negative\" \"negative\" \"negative\" \"positive\" \"positive\" \"positive\" \"positive\"\n```\n\n\n:::\n:::\n\n\n## Loops\n\nLoops are control statements that allow for repeated code execution either for a\nset number of times, over a certain set of elements, or until a conditional\nstatement is met.\n\n### for\n\nA `for` loop will execute commands over a certain set of elements.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(value in vector){\n  ## code to execute for each item in vector\n  ...\n}\n```\n:::\n\nvalue can be utilized in the executed code.\n\n**Examples**\n\nIn this example, the vector of names is looped over, printing the number of\ncharacters in each name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(\"Donna\", \"John\", \"Bradley\", \"Kara\")\nfor(nm in names){\n  print(paste(nm, \"has\", nchar(nm), \"letters\"))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Donna has 5 letters\"\n[1] \"John has 4 letters\"\n[1] \"Bradley has 7 letters\"\n[1] \"Kara has 4 letters\"\n```\n\n\n:::\n:::\n\nIn this example, for each value 1 to 5 (1,2,3,4,5), we take that value and add\nto the current value of x. Notice how this updates x each time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0\nfor(i in 1:5){\n  print(paste(\"add\", i, \"to\", x))\n  x <- x + i\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"add 1 to 0\"\n[1] \"add 2 to 1\"\n[1] \"add 3 to 3\"\n[1] \"add 4 to 6\"\n[1] \"add 5 to 10\"\n```\n\n\n:::\n:::\n\nIn this example, we loop over the elements of a list. For each list element we\nget the name of the item in the list and how many items that list element contains.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(people=names,\n                ages=c(54, 78, 40, 5, 25),\n\t\tanimals=c(\"dog\", \"fish\"))\nfor(i in seq_along(my_list)){\n  list_element <- my_list[[i]]\n  print(paste(\"List element\", names(my_list)[i], \"contains\",\n  length(my_list[[i]]), \"values\"))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"List element people contains 4 values\"\n[1] \"List element ages contains 5 values\"\n[1] \"List element animals contains 2 values\"\n```\n\n\n:::\n:::\n\n### while\n\nA `while` loop will execute until an expression is met.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhile(expression){\n  ## code to execute until the expression is met\n  ## be sure to update variable used in expression\n  ...\n}\n```\n:::\n\nIn this example we will start at the value 1 and as long as that value stays\nless than or equal to 5, we will print the value, incrementing by 1 each loop:\n\n**Example**\n\n::: {.cell}\n\n```{.r .cell-code}\nvalue <- 1\nwhile (value <= 5){\n  print(value)\n  value = value + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n:::\n\n::: {.callout-important}\nNotice how we have to update the value that is being checked each time and that\nit is logical that it should eventually reach a point where the loop exists. Be\ncautious of **infinite loops**. These occur when the loop will never reach a\nstopping point because the expression will never be FALSE\n:::\n\n### repeat\n\n`repeat` is a indefinite loop. A `break` statement must be used to terminate the\nloop.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeat{\n  ## code to be evaluated\n  if (condition){\n    break\n  }\n}\t\n```\n:::\n\nIn this example we will repeat ourself until the breaking conditions reaches the\nnumber of times we set to repeat. Notice how the code inside the loop alters the\nvariable used in the conditional statement. \n\n**Example**\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 0\ntimes <- 3\nrepeat{\n  print(\"I am repeating myself\")\n  i <- i + 1\n  if (i == times){\n    break\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I am repeating myself\"\n[1] \"I am repeating myself\"\n[1] \"I am repeating myself\"\n```\n\n\n:::\n:::\n\n\n## Special\n\nThere are some special other options used to customize control statements. These\nare used within control statements and can be especially useful in nested\nstatements. \n\n<center>\n**break**\n</center>\nWe have already seen `break` usage with repeat. Break will stop and exit the\ncontrol statement immediately when it hits.\n\n<center>\n**return**\n</center>\n\n`return` is similar to break in that it will stop and ext the control statement\nimmediately when it is hit, however it will return the result of the given\nexecuted function or variable value upon exiting. It is generally used within\nfunctions.\n\n**Syntax:**\n\n::: {.cell}\n\n```{.r .cell-code}\nreturn(expression)\n```\n:::\n\n\nThis example creates a function that takes argument x.  If x is equal to 0 it\nreturns the string \"zero\". If it does not equal 0 it continues to execute\ncode. It will add 4 to the value. If that value is less than 0 it returns the\nvalue, otherwise it returns the value multipled by 2. \n\n**Example**\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc <- function(x){\n  if(x == 0){\n    return(\"zero\")\n  }\n  x <- x+4\n  if (x <= 0){\n    return(x)\n  }else{\n    return(x*2)\n  } \n}\n\nfunc(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"zero\"\n```\n\n\n:::\n\n```{.r .cell-code}\nfunc(-8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -4\n```\n\n\n:::\n\n```{.r .cell-code}\nfunc(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n\n<center>\n**next**\n</center>\n\n`next` will skip the current iteration of a loop without executing any further\nstatements without terminating the loop.\n\n**Example**\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:10){\n  if(i%%2 != 0){\n    next\n  }\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n```\n\n\n:::\n:::\n\n\n## Other\n\n### nesting\n\nWe already saw an example of a nesting built into the design of repeat-break;\nnesting an if statement inside the repeat. All control statements can have\nmultiple nesting.\nNesting multiple for loops to loop over the row and columns of a matrix is such\nan example.\n\n**Example:**\n\nIn this example we create a numeric matrix with 5 rows and 3 columns and fill\nthe numbers 1 through 15 by column. Let us loop over by row and print out each\ncell of the matrix. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(1:15, ncol=3)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n```\n\n\n:::\n\n```{.r .cell-code}\nfor (r in seq(nrow(mat))) {\n  for (c in seq(ncol(mat))) {\n    print(mat[r, c])\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 6\n[1] 11\n[1] 2\n[1] 7\n[1] 12\n[1] 3\n[1] 8\n[1] 13\n[1] 4\n[1] 9\n[1] 14\n[1] 5\n[1] 10\n[1] 15\n```\n\n\n:::\n:::\n\n\n### try / tryCatch\n\nThis isn't necessarily a control statement but fits well enough to disucss. A\n`tryCatch` statement is a way to handle code that may produce errors, warnings,\nor other conditions that may arise.\n\n**Syntax:**\n\n::: {.cell}\n\n```{.r .cell-code}\ntryCatch(expr,\n         error = function(e) {\n\t     ## error handling code \n\t },\n         warning = function(w) {\n\t     ## warning handling code \n\t },\n         finally = {\n\t    ## code to execute regardless of conditions\n\t }\n)\n```\n:::\n\nIt can include all error, warning, finally or any subset of the three. expr is\nan expression or block of code that is attempted to be executed. The error if a\nfunction that is triggered if running the expr resulted in an error. The\nargument e is generally an error object that contains details about the error\nfor reference or parsing if necessary. warning similar to error but handles\nwarnings with argument w. finally is code that executed regardless of what\nhappens. This is particularly useful for when the expr opens a connection such\nas a database or file; finally can be used to close or clean up these open\nconnections.\n\n### vectorization and apply functions\n\nSome most common and simply implementations of control functions are to perform\nfunctions over a vector or applying a function over the columns or rows of a\nmatrix. While control statement can be utilized, they may not be the most\nefficient way to accomplish these tasks. It is encouraged to invesetigate if an\nalready existing vectorized function exists for common tasks (mean, average, etc\nare already vectorized) or to utilized apply functions. Apply functions\ninclude: `apply()`, `lapply()`, `sapply()`, `mapply()`, and `tapply()`. \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}