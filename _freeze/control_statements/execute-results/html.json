{
  "hash": "e93ae38638bf0b2c24f87178c2fcec86",
  "result": {
    "engine": "knitr",
    "markdown": "# Control Statements\n\nControl statements help determine the flow and execution of commands based on\nconditional statements. This chapter will cover a brief overview of the\nfollowing:\n\n- Conditional Statements\n  * if\n  * if-else\n  * ifelse\n\n- Loops\n  * for\n  * while\n  * repeat-break\n\n- Special\n  * return\n  * next\n\n- Other\n  * try / tryCatch\n  * nested\n  \n\n::: {.callout-important}\nPay attention to syntax. It is important to include all parenthesis and\nbrackets. In general if you have an open parenthesis or bracket, you will need a\nclosed parenthesis or bracket.\n:::\n\n::: {.callout-tip}\nGood coding practices involve consistent indenting and spacing. Once a control\nstatement is initialized, all code in its brackets are indented to show clearly\nwhat code/statements are being executed for that section. This becomes\nespecially important if you start nesting control statements.  \n:::\n\n## Conditional Statements\n\n### if \n\nLet's start with an `if` statement. An if statement evaluates an expression and\ndepending on its result performs a sub-section of select code.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (expression){\n  # additional code to run if expression is TRUE\n  ...\n}\n```\n:::\n\nThe expression contained in parenthesis will result in a boolean (TRUE/FALSE)\nvalue used to determine if the code in the braces should be executed. \n\n**Example:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 12\nif (x > 0){\n  message(x, \" is greater than 0\")\n  x <- 0\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n12 is greater than 0\n```\n\n\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\nNotice all lines in the braces are executed including a assignment that changes\nour original value\n:::\n\n### if-else\n\nAn `if-else` statement adds additional code to be executed if the expression is\nFALSE.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (expression){\n  # additional code to run if expression is TRUE\n  ...\n} else {\n  # additional code to run if expression if FALSE\n  ...\n}\n```\n:::\n\nWe could read this allowed as if the expression is true execute this code else\nif the expression is false execute this other code.\n\n**Example:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (x > 0){\n  message(x, \" is greater than 0\")\n  x <- 0\n} else {\n  message(x, \" is not greater than 0\")\n  x <- x + 2\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n0 is not greater than 0\n```\n\n\n:::\n:::\n\n\nWhat is x now?\n\n\n### ifelse\n\nA specialized if-else statement is the `ifelse`. It is a simplified version\nwhere an object can be coerced into logical form and return values for\ntrue/false.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nifelse(test_expression, yes_value, no_value)\n```\n:::\n\n\n**Example**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_vec <- -3:3\nifelse(num_vec >= 0, \"positive\", \"negative\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"negative\" \"negative\" \"negative\" \"positive\" \"positive\" \"positive\" \"positive\"\n```\n\n\n:::\n:::\n\n\n## Loops\n\nLoops are control statements that allow for repeated code execution either for a\nset number of times, over a certain set of elements, or until a conditional\nstatement is met.\n\n### for\n\nA `for` loop will execute commands over a certain set of elements.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(value in vector){\n  ## code to execute for each item in vector\n  ...\n}\n```\n:::\n\nvalue can be utilized in the executed code.\n\n**Examples**\n\nIn this example, the vector of names is looped over, printing the number of\ncharacters in each name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(\"Donna\", \"John\", \"Bradley\", \"Kara\")\nfor(nm in names){\n  print(paste(nm, \"has\", nchar(nm), \"letters\"))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Donna has 5 letters\"\n[1] \"John has 4 letters\"\n[1] \"Bradley has 7 letters\"\n[1] \"Kara has 4 letters\"\n```\n\n\n:::\n:::\n\nIn this example, for each value 1 to 5 (1,2,3,4,5), we take that value and add\nto the current value of x. Notice how this updates x each time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0\nfor(i in 1:5){\n  print(paste(\"add\", i, \"to\", x))\n  x <- x + i\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"add 1 to 0\"\n[1] \"add 2 to 1\"\n[1] \"add 3 to 3\"\n[1] \"add 4 to 6\"\n[1] \"add 5 to 10\"\n```\n\n\n:::\n:::\n\nIn this example, we loop over the elements of a list. For each list element we\nget the name of the item in the list and how many items that list element contains.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(people=names,\n                ages=c(54, 78, 40, 5, 25),\n\t\tanimals=c(\"dog\", \"fish\"))\nfor(i in seq_along(my_list)){\n  list_element <- my_list[[i]]\n  print(paste(\"List element\", names(my_list)[i], \"contains\",\n  length(my_list[[i]]), \"values\"))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"List element people contains 4 values\"\n[1] \"List element ages contains 5 values\"\n[1] \"List element animals contains 2 values\"\n```\n\n\n:::\n:::\n\n### while\n\nA `while` loop will execute until an expression is met.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhile(expression){\n  ## code to execute until the expression is met\n  ## be sure to update variable used in expression\n  ...\n}\n```\n:::\n\n\n**Example**\n\n::: {.cell}\n\n```{.r .cell-code}\nvalue <- 1\nwhile (value <= 5){\n  print(value)\n  value = value + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n:::\n\n::: {.callout-important}\nNotice how we have to update the value that is being checked each time and that\nit is logical that it should eventually reach a point where the loop exists. Be\ncautious of **infinite loops**. These occur when the loop will never reach a\nstopping point because the expression will never be FALSE\n:::\n\n### repeat\n\n`repeat` is a indefinite loop. A `break` statement must be used to terminate the\nloop.\n\n**Syntax:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeat{\n  ## code to be evaluated\n  if (condition){\n    break\n  }\n}\t\n```\n:::\n\nIn this example we will repeat ourself until the breaking conditions reaches the\nnumber of times we set to repeat. Notice how the code inside the loop alters the\nvariable used in the conditional statement. \n\n**Example**\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 0\ntimes <- 3\nrepeat{\n  print(\"I am repeating myself\")\n  i <- i + 1\n  if (i == times){\n    break\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I am repeating myself\"\n[1] \"I am repeating myself\"\n[1] \"I am repeating myself\"\n```\n\n\n:::\n:::\n\n\n## Other\n\n### try / tryCatch\n\n### nesting",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}